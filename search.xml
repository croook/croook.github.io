<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tensorflow学习]]></title>
    <url>%2F2020%2F02%2F05%2Ftensorflow%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Tensorflowhello world123456789import tensorflow.compat.v1 as tftf.disable_v2_behavior()vec_1 = tf.constant([1, 2, 3, 4])vec_2 = tf.constant([1, 2, 3, 4])v_add = tf.add(vec_1,vec_2)with tf.Session() as sess: print(sess.run(v_add)) 12345678910111213import tensorflow.compat.v1 as tftf.disable_v2_behavior()vec_1 = tf.constant([1, 2, 3, 4])vec_2 = tf.constant([1, 2, 3, 4])sess = tf.InteractiveSession()v_add = tf.add(vec_1,vec_2)print(v_add.eval())sess.close() 张量所有的数据都通过张量的形式来表示 TensorFlow的张量和Numpy的数组不同，他计算的结果不是一个具体的数字，而是一个张量的结构。从上面结果来看，一个张量主要保存了三个属性，名字（name），维度（shape）和类型（type） 123456789#_*_coding:utf-8_*_import tensorflow as tf # tf.constant 是一个计算，这个计算的结果为一个张量，保存在变量a中a = tf.constant([1.0, 2.0], name='a')b = tf.constant([2.0, 3.0], name='b') result = a + b# print(result) # Tensor("add:0", shape=(2,), dtype=float32) 张量的第一个属性名字不仅是一个张量的唯一标识符，它同样也给出了这个张量是如何计算的，TensorFlow的计算都可以通过计算图的模型来建立，而计算图上的每一个节点代表一个计算，计算的结果就保存在张量之中。所以张量和计算图上节点所代表的计算结果是对应的。所以张量的命名就可以通过“node : src_output”的形式来给出。其中node为节点的名称，src_output 表示当前张量来自节点的第几个输出。比如上面的“add:0” 就说明了result这个张量是计算节点“add” 输出的第一个结果（编号从0 开始）。 张量的第二个属性是张量的维度。这个属性描述了一个张量的维度信息，比如上面样例中 shape = (2, ) 说明了张量 result 是一个一维数组，这个数组的长度为2。维度是张量一个很重要的属性，围绕张量的维度TensorFlow也给出了很多有用的运算。 张量的第三个属性就是类型（type），每一个张量会有一个唯一的类型。TensorFlow 会对参与运算的所有张量进行类型的检查，当发现类型不匹配的时候会报错 常量、随机数、变量大规模常量张量对象最好定义成 t_large = tf.Varible(large_array,trainable = False) 可训练标志位为False 12345678910111213t_1 = tf.constant(4)zero_t = tf.zeros([2,3],tf.int32)tf.zeros_like(t_2)tf.ones_like(t_2)range_t = tf.linspace(2.0,5.0,5)#We get:[2. 2.75 3.5 4.25 5.]tf.range(start,limit,delta)#start 默认0，delta 默认1range_t = tf.range(10)#Result:[0 1 2 3 4 5 6 7 8 9] 123456#随机数t_random = tf.random_normal([2,3],mean=2.0,stddev=4,seed = 12)#要想得到同样的随机数，seed需要设置相同，均值默认0，标准差默认1tf.random_crop(t_random,[2,5],seed=12)#将给定的张量随机剪裁为指定的大小 123456789rand_t = tf.random_uniform([50,50]，0，10，seed=0)t_a = tf.Variable(rand_t)#随机均匀分布，min 0 max 10weight2 = tf.Variable(weights.initialized_value(),name='w2')#用原有变量定义saver = tf.train.Saver()#保存变量 占位符定义过程，执行时再赋具体值 1tf.placeholder(dtype,shape=None,name=None) 常用函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687(1)tf.argmax(input, axis=None, name=None, dimension=None)此函数是对矩阵按行或列计算最大值参数 input：输入Tensor axis：0表示按列，1表示按行 name：名称 dimension：和axis功能一样，默认axis取值优先。新加的字段返回：Tensor 行或列的最大值下标向量 (2)tf.equal(a, b)此函数比较等维度的a, b矩阵相应位置的元素是否相等，相等返回True,否则为False返回：同维度的矩阵，元素值为True或False (3)tf.cast(x, dtype, name=None)将x的数据格式转化成dtype.例如，原来x的数据格式是bool，那么将其转化成float以后，就能够将其转化成0和1的序列。反之也可以 (4)tf.reduce_max(input_tensor, reduction_indices=None,keep_dims=False, name=None) 功能：求某维度的最大值 (5)tf.reduce_mean(input_tensor, reduction_indices=None, keep_dims=False, name=None)功能：求某维度的均值参数1--input_tensor:待求值的tensor。参数2--reduction_indices:在哪一维上求解。0表示按列，1表示按行参数（3）（4）可忽略例：x = [ 1, 2 3, 4]x = tf.constant([[1,2],[3,4]], &quot;float&quot;)tf.reduce_mean(x) = 2.5tf.reduce_mean(x, 0) = [2, 3]tf.reduce_mean(x, 1) = [1.5, 3.5] (6)tf.truncated_normal(shape, mean=0.0, stddev=1.0,dtype=tf.float32, seed=None, name=None)从截断的正态分布中输出随机值 shape: 输出的张量的维度尺寸。 mean: 正态分布的均值。 stddev: 正态分布的标准差。 dtype: 输出的类型。 seed: 一个整数，当设置之后，每次生成的随机数都一样。 name: 操作的名字。 (7）tf.random_normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)从标准正态分布中输出随机值 (8) tf.nn.conv2d(input, filter, strides, padding,use_cudnn_on_gpu=None, data_format=None, name=None)在给定的4D input与 filter下计算2D卷积 1，输入shape为 [batch, height, width, in_channels]: batch为图片数量，in_channels为图片通道数 2，第二个参数filter：相当于CNN中的卷积核，它要求是一个Tensor，具有[filter_height, filter_width, in_channels, out_channels]这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数input相同，有一个地方需要注意，第三维in_channels，就是参数input的第四维 3，第三个参数strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4 4，第四个参数padding：string类型的量，只能是&quot;SAME&quot;,&quot;VALID&quot;其中之一，这个值决定了不同的卷积方式（后面会介绍） 5，第五个参数：use_cudnn_on_gpu:bool类型，是否使用cudnn加速，默认为true 结果返回一个Tensor，这个输出，就是我们常说的feature map，shape仍然是[batch, height, width, channels]这种形式。 (9)tf.nn.max_pool(value, ksize, strides, padding, name=None)参数是四个，和卷积很类似：第一个参数value：需要池化的输入，一般池化层接在卷积层后面，所以输入通常是feature map，依然是[batch, height, width, channels]这样的shape第二个参数ksize：池化窗口的大小，取一个四维向量，一般是[1, height, width, 1]，因为我们不想在batch和channels上做池化，所以这两个维度设为了1第三个参数strides：和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1]第四个参数padding：和卷积类似，可以取&apos;VALID&apos; 或者&apos;SAME&apos; 返回一个Tensor，类型不变，shape仍然是[batch, height, width, channels]这种形式 (10) tf.reshape(tensor, shape, name=None)函数的作用是将tensor变换为参数shape的形式。其中shape为一个列表形式，特殊的一点是列表中可以存在-1。-1代表的含义是不用我们自己指定这一维的大小，函数会自动计算，但列表中只能存在一个-1。（当然如果存在多个-1，就是一个存在多解的方程了） (11)tf.nn.dropout(x, keep_prob, noise_shape=None, seed=None,name=None)为了减少过拟合，随机扔掉一些神经元，这些神经元不参与权重的更新和运算参数： x : 输入tensor keep_prob : float类型，每个元素被保留下来的概率 noise_shape : 一个1维的int32张量，代表了随机产生“保留/丢弃”标志的shape。 seed : 整形变量，随机数种子。 name : 名字，没啥用。 feed_dict字符串拼接123456789Str1 = tf.placeholder(tf.string)Str2 = tf.placeholder(tf.string)Str3 = tf.placeholder(tf.string)Str = tf.string_join([Str1, Str2, Str3], separator=" ") with tf.Session() as sess: output = sess.run(Str, feed_dict=&#123;Str1: 'I', Str2: 'like', Str3: 'TensorFlow !'&#125;) print(output.decode()) 浮点数乘积1234567Num1 = tf.placeholder(tf.float32)Num2 = tf.placeholder(tf.float32)Result = tf.multiply(Num1, Num2)with tf.Session() as sess: print(sess.run(Result, feed_dict=&#123;Num1:[5.],Num2:[6.]&#125;)) tensorboard12345678910import tensorflow.compat.v1 as tftf.disable_v2_behavior()A = tf.random_uniform([2,3] , 2 , 10 , dtype = tf.int32 ,name = "A")B = tf.eye(3 , dtype = tf.int32 , name = "B")C = tf.matmul(A , B , name = "ans")with tf.Session() as sess: write = tf.summary.FileWriter('logs' , sess.graph) sess.run(C) logs上级目录下打开shell，命令： tensorboard --logdir &quot;logs&quot;，新版tensorflow将 = 换成了双引号 更改命名空间： 1234567891011121314import tensorflow.compat.v1 as tftf.disable_v2_behavior()with tf.name_scope("A"): A = tf.random_uniform([2,3] , 2 , 10 , dtype = tf.int32 ,name = "A")with tf.name_scope("B"): B = tf.eye(3 , dtype = tf.int32 , name = "B")C = tf.matmul(A , B , name = "ans")with tf.Session() as sess: write = tf.summary.FileWriter('logs' , sess.graph) sess.run(C)]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HBase]]></title>
    <url>%2F2020%2F01%2F01%2FHBase%2F</url>
    <content type="text"><![CDATA[HBase安装hbase下载wget https://archive.apache.org/dist/hbase/2.0.0-alpha4/hbase-2.0.0-alpha4-bin.tar.gz 安装后解压到/opt/hbase文件夹 配置环境变量修改~/.bashrc文件，添加以下代码 12export HBASE_HOME=/opt/hbase export PATH=$PATH:$HBASE_HOME/bin 立即生效，source ~/.bashrc 修改配置文件修改以下内容，/opt/hbase/conf/hbase-env.sh 12export HBASE_MANAGES_ZK=true export JAVA_HOME=/opt/jdk 使用hbase自带的zookeeper，java路径为/opt/jdk 修改以下内容，/opt/hbase/conf/hbase-site.xml 1234567891011121314151617181920&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://Master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;Master:2181,Slave1:2181,Slave2:2181&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/home/hadoop/zookeeper&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 设置储存位置为hdfs://Master:9000/hbase 使用完全分布式模式，指定zookeeper集群的地址列表，指定zookeeper本地快照位置 修改以下内容：/opt/hbase/conf/regionservers 123MasterSlave1Slave2 HMaster闪退1、时间同步造成HMaster闪退，可能是由于节点的时间未同步，使用ntpdate 123456yum install -y ntpdate#设置时区cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeyes | cp -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime#同步时间ntpdate us.pool.ntp.org 配置后检查各个节点的date，看时间是否同步 2、zookeeper未连接使用hbase自带的zookeeper的话，要保证之前安装的zookeeper不会抢占2181端口，如果已有进程抢占2181端口，使用kill命令杀死进程。 保证各个节点防火墙已关闭，使2181端口能够正常访问 1service iptables stop 启动hbase先启动Hadoop，start -all.sh ，之后启动hbase，使用shell HBase Shellcreate alter删除menber中的member_id列族 list put12345678910111213put 'member','scutshuxue','info:age','24' put 'member','scutshuxue','info:birthday','1987-06-17' put 'member','scutshuxue','info:company','alibaba' put 'member','scutshuxue','address:contry','china' put 'member','scutshuxue','address:province','zhejiang' put 'member','scutshuxue','address:city','hangzhou' put 'member','xiaofeng','info:birthday','1987-4-17' put 'member','xiaofeng','info:favorite','movie' put 'member','xiaofeng','info:company','alibaba' put 'member','xiaofeng','address:contry','china' put 'member','xiaofeng','address:province','guangdong' put 'member','xiaofeng','address:city','jieyang' put 'member','xiaofeng','address:town','xianqiao' get12get 'member','scutshuxue','info' get 'member','scutshuxue','info:age' count Java APIwindows下安装hadoop下载hadoop_2.8.2 解压到合适位置后，添加环境变量 由于是在windows上安装，使用编译好的windows版本二进制文件进行替换，下载地址： https://github.com/steveloughran/winutils 由于没有2.8.2版本，所以使用2.8.3版本替换bin文件夹下全部内容 修改配置文件后，格式化hdfs，到sbin目录下启动hadoop 可以通过http://localhost:8088/ 、 http://localhost:50070/ 查看hadoop相关信息 windows下安装hbase官网下载安装包，版本选择的是 HBase 2.0.0-alpha4，下载地址：http://archive.apache.org/dist/hbase/ 修改环境变量等配置文件，在运行时报错 原因是缺少jar包导致，在网上下载 jline-2.12.1.jar，替换掉hadoop目录里的两个低版本的 jline-0.9.94.jar，并复制一份添加到yarn/lib中去 运行 java项目创建Java项目，导入本机hbase\lib下的所有jar包 创建HBaseUtils类、Run类 建立连接 12345678 HBaseUtils() throws IOException &#123; conf = HBaseConfiguration.create(); conf.set("hbase.rootdir", "hdfs://Master:9000/hbase"); conf.set("hbase.zookeeper.quorum", "Master,Slave1,Slave2"); config.set("hbase.zookeeper.property.clientPort", "2181");// zookeeper端口connection = ConnectionFactory.createConnection(config);admin = conn.getAdmin(); &#125; 创建表 12345678910111213public void createTable(String tableName, String[] family) throws Exception &#123; HTableDescriptor desc =new HTableDescriptor(tableName); for(int i=0;i&lt;family.length;i++)&#123; desc.addFamily(new HColumnDescriptor(family[i])); &#125; if(admin.tableExists(tableName))&#123; System.out.println("Already Exits"); &#125;else&#123; admin.createTable(desc); System.out.println("Create Success"); &#125;&#125; 插入数据 12345678910public void insertRecord(String tableName, String row, String col, String values) throws IOException &#123; createConn(); Table table = conn.getTable(TableName.valueOf(tableName)); Put put = new Put(row.getBytes()); String[] cols = col.split(":"); put.addColumn(cols[0].getBytes(), cols[1].getBytes(), values.getBytes()); table.put(put); table.close(); closeConn();&#125; 删除数据 1234567public void deleteRow(String tName, String row) throws IOException &#123; createConn(); Table table = conn.getTable(TableName.valueOf(tName)); Delete del = new Delete(row.getBytes()); table.delete(del); table.close();&#125; 遍历表 12345678910111213141516171819202122public ResultScanner getResultScann(String tableName) throws Exception &#123; Scan scan=new Scan(); ResultScanner rs =null; HTable htable=new HTable(conf, tableName); try&#123; rs=htable.getScanner(scan); for(Result r: rs)&#123; for(KeyValue kv:r.list())&#123; System.out.println(Bytes.toString(kv.getRow())); System.out.println(Bytes.toString(kv.getFamily())); System.out.println(Bytes.toString(kv.getQualifier())); System.out.println(Bytes.toString(kv.getValue())); System.out.println(kv.getTimestamp()); &#125; &#125; &#125;finally&#123; rs.close(); &#125; return rs; &#125; 结果 在虚拟机中查看结果，可以看到通过java api成功创建了menber表 如果在虚拟机中使用hbase shell时出现错误 Can&#39;t get master address from ZooKeeper; znode data == null 只需重新启动hbase]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Exp</tag>
        <tag>云计算</tag>
        <tag>Hadoop</tag>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce]]></title>
    <url>%2F2020%2F01%2F01%2FMapReduce%2F</url>
    <content type="text"><![CDATA[MapReduce的编程方法与实践MapReduce框架 MapReduce将复杂的，运行大规模集群上的并行计算过程高度地抽象两个函数：Map和Reduce MapReduce采用“分而治之”策略，将一个分布式文件系统中的大规模数据集，分成许多独立的分片。这些分片可以被多个Map任务并行处理。 MapReduce设计的一个理念就是“计算向数据靠拢”，而不是“数据向计算靠拢”，原因是，移动数据需要大量的网络传输开销 MapReduce框架采用了Master/Slave架构，包括一个Master和若干个Slave，Master上运行JobTracker，Slave运行TaskTracker Hadoop框架是用JAVA来写的，但是,MapReduce应用程序则不一定要用Java来写。 Mapper1234567891011121314151617public static class WordCountMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable plugOne = new IntWritable(1); private Text word = new Text(); @Override public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; //使用默认的分隔符，空格、制表符、回车、换行 StringTokenizer st = new StringTokenizer(value.toString().toLowerCase().replaceAll(&quot;[\\pP‘’“”]&quot;, &quot;&quot;)); while (st.hasMoreTokens()) &#123; word.set(st.nextToken()); context.write(word, plugOne); &#125; &#125;&#125; 在map阶段，key/value键值对作为输入，产生另外一系列key/value键值对作为中间输出写入本地磁盘。mapreduce框架自动将这些中间数据按照key值进行聚集，key值相同的数据将一起被reduce处理。 建立test1.txt和test2.txt test1.txt 12I am JackI am the king of the world test2.txt 12I am RoseI am looking for Jack 则map阶段得到的结果为 test1.txt 12345678910&lt;I,1&gt;&lt;am,1&gt;&lt;Jack,1&gt;&lt;I,1&gt;&lt;am,1&gt;&lt;the,1&gt;&lt;king,1&gt;&lt;of,1&gt;&lt;the,1&gt;&lt;world,1&gt; Reduce1234567891011121314151617public static class WordCountReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); @Override public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int reduceSum = 0; for (IntWritable val : values) &#123; reduceSum += val.get(); &#125; result.set(reduceSum); context.write(key, result); &#125;&#125; reduce阶段以key及对应的value列表作为输入，经过合并key相同的value值后，产生另外一系列key/value对作为最终输出写入hdfs map处理完后，得到的KV对会分组保存，key值相同的分为一组，然后传递一个组会调用一次reduce，在词频统计中，同一个单词会分为一组，value的值为1，所以reduceSum += val.get() 统计了每一个单词的个数。 结果： Sort由于只需要出现次数最多的100个单词，所以采用TreeMap结构 建立新的sortjob，继承mapper和reducer mapper 12345678910111213public void map(final Object key, final Text value, final Context context) throws IOException, InterruptedException &#123; final String line = value.toString(); final String[] keyValueStrings = line.split(&quot;\t&quot;); final int count = Integer.parseInt(keyValueStrings[1]); final String word = keyValueStrings[0]; map1.put(count, word); if (map1.size() &gt; K) &#123; map1.remove(map1.firstKey()); &#125; &#125; reducer 1234567891011121314public void reduce(final Text key, final Iterable&lt;IntWritable&gt; values, final Context context) throws IOException, InterruptedException &#123; final String word = key.toString(); int count = 0; for (final IntWritable val : values) &#123; count = val.get(); &#125; map1.put(count, word); if (map1.size() &gt; K) &#123; map1.remove(map1.firstKey()); &#125; &#125; 上传ebooks在hdfs根目录建立文件夹ebooks 使用scp将200本英文书上传到虚拟机： hadoop fs -put /ebooks / 将文件上传到hdfs目录下 可以看到文件上传成功 运行编辑run.sh 编译后的结果： 第一次运行时，在运行过程中会被强制kill掉进程，返回码为137 原因是内存分配不足造成，需要修改配置文件 yarn-site.xml ，添加以下内容 1234567891011121314151617&lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt; &lt;value&gt;22528&lt;/value&gt; &lt;discription&gt;每个节点可用内存,单位MB&lt;/discription&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt; &lt;value&gt;1500&lt;/value&gt; &lt;discription&gt;单个任务可申请最少内存，默认1024MB&lt;/discription&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt; &lt;value&gt;16384&lt;/value&gt; &lt;discription&gt;单个任务可申请最大内存，默认8192MB&lt;/discription&gt; &lt;/property&gt; mapred-site.xml ，添加以下内容 12345678910111213141516171819202122232425&lt;property&gt; &lt;name&gt;mapreduce.map.memory.mb&lt;/name&gt; &lt;value&gt;1500&lt;/value&gt; &lt;description&gt;每个Map任务的物理内存限制&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.reduce.memory.mb&lt;/name&gt; &lt;value&gt;3000&lt;/value&gt; &lt;description&gt;每个Reduce任务的物理内存限制&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.map.java.opts&lt;/name&gt; &lt;value&gt;-Xmx1200m&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.reduce.java.opts&lt;/name&gt; &lt;value&gt;-Xmx2600m&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; result]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Exp</tag>
        <tag>云计算</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdfs使用方法]]></title>
    <url>%2F2020%2F01%2F01%2Fhdfs%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[HDFS使用方法一、使用命令操作HDFS查看文件、发送文件hadoop fs -ls / 查看hdfs根目录文件 hadoop fs -put ./test/file1 / 将test目录下的file1发送到hdfs根目录 创建目录hadoop fs -mkdir -p /test/user/ -p为递归创建，可以创建多级目录 下载文件、删除文件hadoop fs -get sourcepath savepath 将hdfs test 文件夹下的user文件夹 下载到本地的test文件夹下 hadoop fs -rm -r /test/user/del 删除 test/user 下的del文件，-r循环删除文件夹下的所有文件 查找文件hadoop fs -find / -name xxx 从根目录开始查找名为xxx的文件位置 二、使用Java接口操作HDFS添加环境变量123修改 .bashrc，添加export HADOOP_CLASSPATH=$JAVA_HOME/lib/tools.jarsource .bashrc 编写Java代码实现 put 、 delete、get三个方法 参考老师的PPT 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;public class hadoop_try&#123; public static Boolean put(String src , String dst , Configuration conf)&#123; Path dstPath = new Path(dst) ; try&#123; FileSystem hdfs = dstPath.getFileSystem(conf) ; hdfs.copyFromLocalFile(false, new Path(src), dstPath) ; &#125; catch(IOException ie)&#123; ie.printStackTrace() ; return false ; &#125; return true ; &#125; public static Boolean get(String src , String dst , Configuration conf)&#123; Path dstPath = new Path(dst) ; try&#123; FileSystem dhfs = dstPath.getFileSystem(conf) ; dhfs.copyToLocalFile(false, new Path(src), dstPath) ; &#125; catch(IOException ie)&#123; ie.printStackTrace() ; return false ; &#125; return true ; &#125; public static Boolean Delete(final String path , Configuration conf)&#123; Path dstPath = new Path(path) ; try&#123; FileSystem dhfs = dstPath.getFileSystem(conf) ; if(dhfs.exists(dstPath))&#123; dhfs.delete(dstPath, true) ; &#125; else&#123; return false ; &#125; &#125; catch(IOException ie )&#123; ie.printStackTrace() ; return false ; &#125; return true ; &#125; public static void main(String[] args) &#123; String dst = "hdfs://Master:9000/test/user" ; String src = "/root/test/tryfile"; Boolean status = false ; Configuration conf = new Configuration() ; status = put( src , dst , conf) ; System.out.println("put status="+status) ; src = "hdfs://Master:9000/test/user/tryfile"; dst = "/root/" ; status = get( src , dst , conf) ; System.out.println("get status="+status) ; dst = "hdfs://Master:9000/test/user/tryfile"; status = Delete( dst , conf) ; System.out.println("del status="+status) ; &#125;&#125; 编译、打包、运行123编译 ： hadoop com.sun.tools.javac.Main hadoop_try.java打包 ： jar cf hadoop_try.jar hadoop_try*.class运行 ： hadoop jar hadoop_try.jar hadoop_try 通过get方法，将hdfs上 /test/user/tryfile 下载到了 root文件夹下 ， 验证：]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Exp</tag>
        <tag>云计算</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop安装配置]]></title>
    <url>%2F2019%2F11%2F05%2FHadoop%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Hadoop平台安装与配置一、创建三台虚拟机1、 为创建好的虚拟机配置网络使用命令 vi /etc/sysconfig/network-scripts/ifcfg-eth0 重启服务，并验证配置好的网络 2、 使用模板创建另外两台虚拟机使用实验一中创建的CentOS 6虚拟机，并使用OVF模板创建另外两台虚拟机 二、配置网络1、 生成MAC地址由于直接使用OVF模板创建了虚拟机，所以需要为两台模板虚拟机生成MAC地址 2、 修改MAC地址使用命令 vi /etc/sysconfig/network-scripts/ifcfg-eth0 删除旧网卡规则映射 使用命令 rm /etc/udev/rules.d/70-persistent-net.rules 删除后重启机器 3、 修改ip、子网掩码、网关使用命令 ifconfig 、 netstat -rn 查看ip、子网掩码、网关地址 修改ip、子网掩码、网关，在网卡配置中增加 IPADDR、NETMASK、GATEWAY 4、重启服务，关闭防火墙12service network restartservice iptables stop 5、 测试网络三个虚拟机ip: 123CentOS 6 : 192.168.112.129CentOS 6 - 1 : 192.168.112.130CentOS 6 - 2 : 192.168.112.131 测试网络： 三、修改hosts1、分别修改虚拟机hosts文件使用命令 vi /etc/hosts 四、配置SSH免登录1、ssh-keygen使用命令 ssh-kengen 2、配置两两间的免登录12ssh-copy-id -i .ssh/id_rsa.pub root@Slave1 ssh-copy-id -i .ssh/id_rsa.pub root@Slave2 五、安装Hadoop平台1、安装java 2、将下载的java安装包传入虚拟机 3、解压12tar -zxvf jdk-8u231-linux-x64.tar.gz mv ./jdk1.8.0_231 /opt/jdk 4、添加环境变量vi /etc/profile 12export JAVA_HOME=/opt/jdkCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin 5、安装Hadoop网址： https://archive.apache.org/dist/hadoop/core/hadoop-2.8.2/ 解压后添加环境变量，修改 .bashrc 添加 12export HADOOP_HOME=/opt/hadoop export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin 修改 hadoop-env.sh 和 yarn-env.sh 1export JAVA_HOME=/opt/jdk 修改 slaves ，添加Slave1、Slave2 修改 core-site.xml 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://Master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/tmp&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改 hdfs-site.xml ， 设置副本数、心跳间隔 12345678910111213141516171819202122&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;value&gt;Master:50070&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.heartbeat.interval&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/tmp/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/tmp/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 mapred-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改 yarn-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 格式化文件系统 hdfs namenode -format 启动Hadoop start-all.sh 查看jps]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Exp</tag>
        <tag>云计算</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题baidu验证]]></title>
    <url>%2F2019%2F10%2F11%2Fhexo_baidu_verify%2F</url>
    <content type="text"><![CDATA[baidu验证验证未收录百度搜索 site:yourgithub.github.io , 验证未收录 百度搜索平台进入百度搜索平台，点击链接提交，填写github地址 记录content值验证站点，选择html标签验证，记录content值 添加代码在themes/next下的配置文件最后添加代码 baidu_site_verification: 5xxxxxxQ 重新生成提交，无需修改head文件 刷新github页面，查看网站源代码，当可以找到正确的验证标签时，进行验证。 验证通过 等待通过，通过后进行推送 推送主动推送最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 自动推送最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。 sitemap您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。 手动提交一次性提交链接给百度，可以使用此种方式。 主动推送&gt;自动推送&gt;sitemap主动推送安装hexo-baidu-url-submit插件git bash 命令 npm install hexo-baidu-url-submit --save 添加baidu-url-submit的配置项站点配置文件中添加： #设置百度主动推送baidu_url_submit: count: 200 #比如200，代表提交最新的200个链接 host: www.lansheng.net.cn # 在百度站长平台中注册的域名，这个改为你自己的域名 token: your_token # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，这个默认 同时注意修改站点配置文件中的url值 加入新的deploy配置项两个type前都要加‘ - ’，表明层次 deploy: - type: gitrepo: coding: git@git.coding.net:你的coding用户名/你的coding用户名.coding.me.git #coding地址 github: git@github.com:你的github用户名/你的github用户名.github.io.git # Github地址branch: master - type: baidu_url_submitter 验证配置是否成功hexo d部署后查看反馈： 自动推送设置baidu_push将主题配置文件中的baidu_push置为 true 自动推送代码位于 themes\next\layout\_third-party\baidu-push.swig Sitemap安装baidu 、Google插件git bash命令 npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 修改配置文件修改站点配置文件，添加 # 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 编译hexo clean &amp;&amp; hexo g 更换站点地图文件url将地图文件中的yoursite.com更换成自己的url 在站长管理中提交地图]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>baidu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汽车牌照提取]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%B1%BD%E8%BD%A6%E7%89%8C%E7%85%A7%E6%8F%90%E5%8F%96%2F</url>
    <content type="text"><![CDATA[​ 问题分析车牌特点样例车牌可以分为两类： （1） 小功率汽车使用的蓝底白字牌照； （2） 国外驻华机构使用黑底白字牌照 这些牌照的长度均为45cm，宽为15cm，共有字符7个。一般民用牌照第一个字符为汉字，且是各省市的简称；第二个字符为大写英文字母，如“E”；第三个字符是英文字母或阿拉伯数字，第四至第七个字符为阿拉伯数字。 实验流程实验流程包括：车牌定位、倾斜校正、字符分割、字符识别4个部分 (1) 原始图像：样例中所给的汽车图像； (2) 图像预处理：对原始图像进行二值化等预处理操作； (3) 车牌定位：定位出汽车牌照所在的矩形范围； (4) 倾斜校正：对定位后的车牌进行倾斜校正； (5) 字符分割：定位分割得到的车牌图像，得到单个的字符； (6) 图像预处理：重新定义分割后的字符图像大小，并转化为一维矩阵； (7) 字符识别：通过BP神经网络训练，得到最后的汽车牌照，包括英文字母和数字。 实验过程解决思路车牌定位1) 基于灰度边缘检测与形态学重构的方法。这种方法只要利用车牌区域局部对比度明显和有规律的纹理特征来定位，然后利用形态学方法将车牌区域与其它背景区域分离。 2) 基于直线检测的方法。这种方法主要Hough变换的方法来检测车牌周围边框直线，利用车牌形状特性来定位车牌。 3) 根据车牌的固有长宽比进行定位的方法。因为中外车牌的长宽比都是固定的3.1：1，在预处理完成后对二值化的图像进行膨胀腐蚀，计算联通区域长宽比确定车牌位置。 4) 基于彩色图像的车牌定位方法。现在的牌照有四种类型:第一种是最常见的小型汽车所用的蓝底白字牌照；第二种是大型汽车所用的黄底黑字牌照；第三种是军用或警用的白底黑字、红字牌照；第四种是国外驻华机构用的黑底白字、红字牌照。基于彩色图像的车牌定位方法主要利用车牌颜色与车身其他部位颜色具有明显不同的差异来分割与提取车牌。 5) 目前较为成熟的车牌区域定位算法有自适应边界搜索法、区域生长法、灰度图像数学形态学运算法、基于纹理或颜色的分割方法以及模糊聚类法等。 字符分割1) 投影分析常采用的是水平投影法。即沿水平方向计算每一列属于车牌字符的象素数目，在字符的间隙处取得局部最小值，分割位置应在其附近。先根据车牌水平投影的统计特征呈现出明显“波峰——波谷——波峰”，进行水平方向上的粗分割，若字符出现合并和粘连现象，再采用递归回归办法进行二次字符分割。 2) 投影法进行字符分割实现起较为简单，但在预处理效果不好的情况下，较难获得满足条件的列。若增加预处理，则使处理后的图像不可避免地损失一部分有用信息，还可能导致额外误差。基于连通域聚类分析切分车牌字符的方法按照属于同一个字符的像素构成一个连通域的原则，结合牌照字符的固定高度和间距比例关系等先验知识，较好地解决了汽车牌照在复杂背景条件下的字符切分问题，降低了对车牌定位准确度的要求，对不规范的车牌识别也具有一定的适用性。 字符识别1) 模板匹配法是最简单的一种字符识别方法。将待识别字符经分割归一化成模板字体的大小，将它输入字符识别模块进行匹配。根据实际字符和模板图像之间匹配方差最小的原则，判定车牌图像字符所属类别。这种方法对于标准、规范的字符识别效果较好。但在复杂环境下的车牌字符会与理想模板字符不完全一致，这导致了识别结果存在较大误差。 2) 模版匹配法简单、成熟，但其自适应不强。对于字符有断裂和粘连等情况容易造成误判。神经网络匹配法具有良好的容错性、自适应和学习能力，但样本的训练收敛速度慢，而大规模并行处理为此提供了解决途径。其中一种方法是采用并行识别的BP网络，让汉字、英文、阿拉伯数字，阿拉伯数字分别送到各自的网络识别。还有学者结合小波变化的优点，提出基于小波和BP神经网络的车牌字符识别新方法，采用小波变换提取字符特征，神经网络实现字符识别，加快了算法的执行，提高了识别率。 方法设计车牌定位1) 边缘检测方法 采用robert、prewitt、soble算子进行边缘检测，之后利用数学形态学的方法对边缘检测后得到的图像进行线性腐蚀、闭运算等操作得到初步定位的二值化车牌位置 2) 颜色提取方法 针对蓝底、黑底车牌，确定颜色提取的范围，进行颜色提取，提取后得到图像的逻辑矩阵，逻辑为真的部分为初步定位的二值化车牌位置 3) 根据行、列像素灰度值累积值确定行列起始、终止位置。 4) 将逻辑矩阵初步确定的车牌位置的外接矩形作为车牌最终定位位置 倾斜校正1) 理想情况下，将车牌左上角，右上角连线与水平方向的夹角作为倾角。 2) 将定位后的车牌等分为左右两部分，求出平均y值，作为倾角。 字符分割1) 水平投影法。沿水平方向计算每一列属于车牌字符的像素数目，在字符的间隙处取得局部最小值，分割位置应在其附近。先根据车牌水平投影的统计特征呈现出明显“波峰——波谷——波峰”，进行分割。 2) 首先计算列级灰度值，确定阈值范围，将满足阈值范围的列号设为逻辑真值1，用连续的两个0作为分割符，进行初步分割，对分割后的部分进行判断，取连续超过5个的逻辑真值列，作为分割后的字符位置。 字符识别1) 使用matlab自带的bp神经网络进行训练 小组分工描述小组成员的分工情况，每个人需要完成的任务 实现过程牌照定位边缘检测首先采用边缘检测的方法进行定位，利用robert算子，进行边缘提取，之后利用腐蚀，闭运算填充的方法，得到初步的结果，之后根据车牌的大小，通过做差，提取出车牌部分 123456789101112131415161718192021222324252627282930313233a = imread(&apos;pics/2.jpg&apos;);I = edge(rgb2gray(a),&apos;roberts&apos;,0.07,&apos;both&apos;); %采用robert算子进行边缘检测 figure , subplot(1,2,1);imshow(I) , title(&apos;边缘检测&apos;); se = [1;1;1];I1 = imerode(I,se);%figure , imshow(I1) , title(&apos;膨胀后&apos;); se=strel(&apos;rectangle&apos;,[25,25]); %矩形结构元素I2 = imclose(I1,se); %初步填充I3 = bwareaopen(I2,9000); %去除聚团灰度值小于9000的部分I4 = bwareaopen(I2,11000); subplot(1,2,2)imshow(I3-I4) , title(&apos;填充后&apos;); 但是这种方法对于样例4，得到的结果并不理想 因此改用颜色提取的方法 颜色提取根据蓝底和黑底车牌，确定不同的颜色范围，进行颜色提取。 以蓝底车牌为例： 123456789101112131415161718192021222324252627282930313233a = imread(&apos;pics/2.jpg&apos;); dd1 = (a(:,:,1)&lt;=40&amp;a(:,:,1)&gt;=10&amp;a(:,:,2)&lt;=85&amp;a(:,:,2)&gt;=55&amp;a(:,:,3&lt;=240&amp;a(:,:,3)&gt;=110); %由RGB颜色范围抠图 结果为逻辑矩阵（只包含0与1）figure , subplot(1,2,1),imshow(dd1) , title(&apos;颜色提取&apos;); se = strel(&apos;square&apos;,3); %线型结构元素 I1 = imdilate(imdilate(dd1,se),se); %膨胀图像 se=strel(&apos;rectangle&apos;,[20,20]); %矩形结构元素I2 = imclose(I1,se); %初步填充 I3 = bwareaopen(I2,2000); %去除聚团灰度值小于2000的部分 se=strel(&apos;rectangle&apos;,[100,100]); %矩形结构元素I = imclose(I3,se); %再次填充subplot(1,2,2)imshow(I) , title(&apos;填充后&apos;); 确定范围首先尝试通过行列的像素灰度值进行最终范围的确定，但得到的最终范围会损失一些有用信息，因此改用外接矩形的方法。 由于颜色提取后的车牌位置已经比较准确，所以将颜色提取后车牌位置的x,y轴极大极小值作为最终的范围 倾斜校正(1) 在理想情况下，由于车牌为矩形，可以通过车牌的左上角和右上角确定倾角。但在实际识别过程中，定位的车牌左上角以及右上角并不准确，导致倾角误差较大。 (2) 将定位后的车牌等分为左右两部分，求出平均y值，作为倾角。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137[y,x,]=size(I); minx = 0;maxx = x;for i = 1:y for j = 1:x if(I(i,j,1) == 1) if(minx == 0) minx = j; elseif(minx &gt; j) minx = j; end if(maxx == x) maxx = j; elseif(maxx &lt; j) maxx = j; end end endend miny = 0;maxy = y;sumofleft = 0;sumofright = 0;heightofleft = 0;heightofright = 0; for j = minx:int64((minx+maxx)/2) for i = 1:y if(I(i,j,1) == 1) sumofleft = sumofleft + 1; heightofleft = heightofleft + i; if(miny == 0) miny = i; elseif(miny &gt; i) miny = i; end if(maxy == y) maxy = i; elseif(maxy &lt; i) maxy = i; end end endend for j = int64((minx+maxx)/2):maxx for i = 1:y if(I(i,j,1) == 1) sumofright = sumofright + 1; heightofright = heightofright + i; if(miny &gt; i) miny = i; end if(maxy &lt; i) maxy = i; end end endend 旋转aveleft = heightofleft/sumofleft;averight = heightofright/sumofright;k = (aveleft - averight)/((maxx - minx)/2);DW = imrotate(DW,-atan(k)*180/pi); 字符分割(1) 首先计算列级灰度值，确定阈值范围，将满足阈值范围的列号设为逻辑真值1，用连续的两个0作为分割符，进行初步分割，对分割后的部分进行判断，取连续超过5个的逻辑真值列，作为分割后的字符位置。 先对定位后的图像进行再次抠图，得到更精确的逻辑矩阵，之后设立一维矩阵selectcol，如果列级灰度值的范围在（2，20），则将selectcol对应的列置为1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546a = DW;dd1 = (a(:,:,1)&lt;=200&amp;a(:,:,1)&gt;=100&amp;a(:,:,2)&lt;=220&amp;a(:,:,2)&gt;=100&amp;a(:,:,3)&lt;=220&amp;a(:,:,3)&gt;=100); %由RGB颜色范围抠图 结果为逻辑矩阵（只包含0与1）% figure , subplot(1,2,1),imshow(dd1);[y,x,]=size(dd1);sumofrow = 0;sumofcol = 0;selectrow = zeros(y,1);selectcol = zeros(1,x);row_min = 1;row_max = y;for i = 1:y sumofrow = 0; for j = 1:x if(dd1(i,j) == 1) sumofrow = sumofrow + 1; end end if(sumofrow &gt; 0 &amp;&amp; sumofrow &lt; 20) selectrow(i,1) = 1; endendfor i = 1:y if(selectrow(i,1) == 1) row_min = i; break; endendfor i = y:-1:1 if(selectrow(i,1) == 1) row_max = i; break; endendfor j = 1:x sumofcol = 0; for i = row_min:row_max if(dd1(i,j) == 1) sumofcol = sumofcol + 1; end if(sumofcol &gt; 2 &amp;&amp; sumofcol &lt; 20) selectcol(1,j) = 1; end endend 之所以要将范围下限设置为2，是为了排除一些干扰，由于下一步的分割要用连续的两个0作为分割符，但是对于图片五来说，第四个和第五个数字‘0’上方出现了车牌铆钉的干扰，如果不设置下界，则第四个和第五个数字被识别为连续的部分，不能进行分割。 分割以连续的两个0作为分割符，并且只取长度超过5的部分（这是为了排除包括车牌中点号在内的干扰） 12345678910111213141516171819202122232425262728293031323334353637383940414243[y,x,]=size(dd1);sum = 0;cur = 1;% figure;for i = 1:7 sum = 0; while(sum &lt; 5) while(cur &lt; x &amp;&amp; selectcol(1,cur) == 0) cur = cur + 1; end if(cur &gt; x-3) break; end tempstart = cur; while(~(selectcol(1,cur+1) == 0 &amp;&amp; selectcol(1,cur+2) == 0) &amp;&amp; cur &lt; x-3) sum = sum + 1; cur = cur + 1; end cur = cur + 1; end tempend = cur; z = dd1(1:y,tempstart:tempend,:);% se=strel(&apos;rectangle&apos;,[2,2]); %矩形结构元素% z = imclose(z,se); %再次填充 switch (i) case 1 pic1 = z; case 2 pic2 = z; case 3 pic3 = z; case 4 pic4 = z; case 5 pic5 = z; case 6 pic6 = z; case 7 pic7 = z; end subplot(1,7,i),imshow(z);end 字符识别建立模板库模板库中包含部分字母以及数字 预处理12345678910111213function inpt = pretreatment(I)% 训练样本前期处理if (ndims(I)==3) I1 = rgb2gray(I);else I1=I;endI1=imresize(I1,[50 25]);%将图片统一划为50*25大小I1=im2bw(I1,0.9);[m,n]=size(I1);inpt=zeros(1,m*n);% 将图像按列转换成一个行向量for j=1:n BP神经网络训练123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112close all;clear all;% 归一化训练样本I0=pretreatment(imread(&apos;pics/num0.png&apos;));I1=pretreatment(imread(&apos;pics/num1.png&apos;));I2=pretreatment(imread(&apos;pics/num2.png&apos;));I3=pretreatment(imread(&apos;pics/num3.png&apos;));I4=pretreatment(imread(&apos;pics/num4.png&apos;));I5=pretreatment(imread(&apos;pics/num5.png&apos;));I6=pretreatment(imread(&apos;pics/num6.png&apos;));I7=pretreatment(imread(&apos;pics/num7.png&apos;));I8=pretreatment(imread(&apos;pics/num8.png&apos;));I9=pretreatment(imread(&apos;pics/num9.png&apos;));I10=pretreatment(imread(&apos;pics/charA.png&apos;));I11=pretreatment(imread(&apos;pics/charB.png&apos;));I12=pretreatment(imread(&apos;pics/charC.png&apos;));I13=pretreatment(imread(&apos;pics/charD.png&apos;));I14=pretreatment(imread(&apos;pics/charK.png&apos;));I15=pretreatment(imread(&apos;pics/charM.png&apos;));I16=pretreatment(imread(&apos;pics/charP.png&apos;));I17=pretreatment(imread(&apos;pics/charQ.png&apos;));P=[I0&apos;,I1&apos;,I2&apos;,I3&apos;,I4&apos;,I5&apos;,I6&apos;,I7&apos;,I8&apos;,I9&apos;,I10&apos;,I11&apos;,I12&apos;,I13&apos;,I14&apos;,I15&apos;,I16&apos;,I17&apos;];T=eye(18,18); %输出样本% bp神经网络参数设置net=newff(minmax(P),[1250,300,18],&#123;&apos;logsig&apos;,&apos;logsig&apos;,&apos;logsig&apos;&#125;,&apos;trainrp&apos;);net.inputWeights&#123;1,1&#125;.initFcn =&apos;randnr&apos;;net.layerWeights&#123;2,1&#125;.initFcn =&apos;randnr&apos;;net.trainparam.epochs=5000;net.trainparam.show=50;%net.trainparam.lr=0.01;net.trainparam.goal=0.000000000001;net=init(net);[net,tr]=train(net,P,T); %训练样本% 测试path = &apos;pics/2.jpg&apos;;[PIN0,PIN1,PIN2,PIN3,PIN4,PIN5,PIN6]=blue_main(path);%字符分割及处理% 测试字符，得到识别数值PIN0=pretreatment(PIN0);PIN1=pretreatment(PIN1);PIN2=pretreatment(PIN2);PIN3=pretreatment(PIN3);PIN4=pretreatment(PIN4);PIN5=pretreatment(PIN5);PIN6=pretreatment(PIN6);P0=[PIN0&apos;,PIN1&apos;,PIN2&apos;,PIN3&apos;,PIN4&apos;,PIN5&apos;,PIN6&apos;];for i=2:7 T0= sim(net ,P0(:,i)); T1 = compet (T0) ; d = find(T1 == 1) - 1; if (d==10) str=&apos;A&apos;; elseif (d==11) str=&apos;B&apos;; elseif (d==12) str=&apos;C&apos;; elseif (d==13) str=&apos;D&apos;; elseif (d==14) str=&apos;K&apos;; elseif (d==15) str=&apos;M&apos;; elseif (d==16) str=&apos;P&apos;; elseif (d==17) str=&apos;Q&apos;; elseif (d==0) str=&apos;0&apos;; elseif (d==1) str=&apos;1&apos;; elseif (d==2) str=&apos;2&apos;; elseif (d==3) str=&apos;3&apos;; elseif (d==4) str=&apos;4&apos;; elseif (d==5) str=&apos;5&apos;; elseif (d==6) str=&apos;6&apos;; elseif (d==7) str=&apos;7&apos;; elseif (d==8) str=&apos;8&apos;; elseif (d==9) str=&apos;9&apos;; else str=num2str(d); end switch i case 2 str2=str; case 3 str3=str; case 4 str4=str; case 5 str5=str; case 6 str6=str; otherwise str7=str; endend% 识别出的结果以标题形式显示在图上S=strcat(&apos;鲁&apos;,str2,&apos; &apos;,str3,str4,str5,str6,str7); figure();imshow(imread(path)),title(S); 结果呈现]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式]]></title>
    <url>%2F2019%2F05%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[规范化过程 过程 影响 1NF ——-&gt; 2NF 消除非主属性对码的部分函数依赖 2NF ——-&gt; 3NF 消除非主属性对码的传递函数依赖 3NF ——-&gt; BCNF 消除主属性对码的部分、传递函数依赖 BCNF——&gt; 4NF 消除非平凡且非函数以来的多值依赖 4NF ——-&gt; 5NF 消除连接依赖 范式1NF定义符合1NF的关系中的每个属性都不可再分 不满足1NF 特点1NF是所有关系型数据库的最基本要求，在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，只要在RDBMS中已经存在的数据表，一定是符合1NF的。 修改后满足1NF的关系： 缺陷 学号 姓名 系名 系主任 课名 分数 101 Tom 经济 Jack 数据库 95 101 Tom 经济 Jack 英语 85 101 Tom 经济 Jack 语文 75 102 Jerry 经济 Jack 数据库 98 102 Jerry 经济 Jack 英语 55 102 Jerry 经济 Jack 音乐 75 103 Pikachu 法律 Rose 民法 85 103 Pikachu 法律 Rose 数据库 92 数据冗余每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次 插入异常假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 删除异常假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了） 修改复杂假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据 2NF改进2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖 概念函数依赖若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。 在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。 例如，对于上图中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作 学号 → 姓名。但是反过来，因为可能出现同名的学生，所以有可能存在不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。 表中其他的函数依赖关系还有如： 系名 → 系主任 学号 → 系主任 （学号，课名） → 分数 但以下函数依赖关系则不成立： 学号 → 课名 学号 → 分数 课名 → 系主任 （学号，课名） → 姓名 完全函数依赖在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ‘ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作$X-^F-&gt;Y$ 例如： 学号$-F-&gt;$姓名 （学号、课名）$-F-&gt;$分数 部分函数依赖假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X $-P-&gt;$ Y 例如：（学号、课名）$-P-&gt;$ 姓名 传递函数依赖假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X ，记作 X $-T-&gt;$ Z 码设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K，那么我们称 K 为候选码，简称为码。在实际中我们通常可以理解为： 假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码） 例如：（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况） 主属性包含在任何一个码中的属性成为主属性 非主属性除了主属性之外的属性 判断是否为2NF根据2NF的定义，判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖。 若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是： 第一步：找出数据表中所有的码。 第二步：根据第一步所得到的码，找出所有的主属性。 第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。 第四步：查看是否存在非主属性对码的部分函数依赖。 我们可以这么做： 第一步： 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。 …… 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。 看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组， 如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“完全函数依赖”） 关系如下： 第一步： 码只有一个，就是（学号、课名） 第二步： 主属性有两个：学号 与 课名 第三步： 非主属性有四个：姓名、系名、系主任、分数 第四步： 对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码（学号，课名）的部分函数依赖。对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码（学号，课名）的部分函数依赖。对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 对码（学号，课名）的部分函数依赖。 所以上图只满足1NF而不满足2NF 模式分解为了符合2NF的要求，必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法：选课（学号，课名，分数）学生（学号，姓名，系名，系主任） 验证模式分解后是否满足2NF：对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数 对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。 对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。 模式分解后： 学号 课名 分数 101 数据库 95 101 英语 85 101 语文 75 102 数据库 98 102 英语 55 102 音乐 75 103 民法 85 103 数据库 92 2NF_T2: 学号 姓名 系名 系主任 101 Tom 经济 Jack 102 Jerry 经济 Jack 103 Pikachu 法律 Rose 缺陷数据冗余学生的姓名、系名与系主任，不再像之前一样重复那么多次了 插入异常因为学生表的码是学号，不能为空，所以此操作不被允许 删除异常删除某个系中所有的学生记录，该系的信息仍然全部丢失 修改复杂李小明转系到法律系，只需要修改一次李小明对应的系的值即可 3NF改进3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 判断是否为3NF对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。 对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。 模式分解分解为： 选课（学号，课名，分数）学生（学号，姓名，系名）系（系名，系主任） 对于选课表，符合3NF的要求 对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求 对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求 关系如下： 3NF_T1: 学号 课名 分数 101 数据库 95 101 英语 85 101 语文 75 102 数据库 98 102 英语 55 102 音乐 75 103 民法 85 103 数据库 92 3NF_T2: 学号 姓名 系名 101 Tom 经济 102 Jerry 经济 103 Pikachu 法律 3NF_T3: 系名 系主任 经济 Jack 经济 Jack 法律 Rose 缺陷数据冗余进一步减少 插入异常插入一个尚无学生的新系的信息，因为系表与学生表目前是独立的两张表，所以不影响 删除异常删除某个系中所有的学生记录，该系的信息不会丢失 修改复杂进一步改善 BCNF改进在 3NF 的基础上消除主属性对于码的部分与传递函数依赖 若： 某公司有若干个仓库； 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作； 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。 那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？ 答： 已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量码：（管理员，物品名），（仓库名，物品名）主属性：仓库名、管理员、物品名非主属性：数量∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF 仓库名 管理员 物品名 数量 Shanghai Jack iphoneXXX 30 Shanghai Jack Ipadmini 50 Beijing Rose HuaweiP30 20 Beijing Rose Matebook14 100 插入异常对于上表，先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？ ——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空 删除异常某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？ ——仓库本身与管理员的信息也被随之删除了 修改复杂如果某仓库更换了管理员，会带来什么问题？ ——这个仓库有几条物品存放记录，就要修改多少次管理员信息 模式分解仓库（仓库名，管理员）库存（仓库名，物品名，数量） 仓库名 管理员 Shanghai Jack Beijing Rose 仓库名 物品名 数量 Shanghai iphoneXXX 30 Shanghai Ipadmini 50 Beijing HuaweiP30 20 Beijing Matebook14 100 数据冗余有改进 插入异常可以单独增加仓库 删除异常当删除某个仓库所有物品时，仓库信息得以保留 修改复杂当某个仓库更改管理员时，只需要修改一条数据]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Exp</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语言SUM到栈式计算机STACK的机器语言的翻译]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%AF%AD%E8%A8%80SUM%E5%88%B0%E6%A0%88%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BASTACK%E7%9A%84%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[实验内容sum.c是用c语言写的从sum语言到栈式计算机STACK的机器语言的编译器（省略了词法语法分析部分）。该程序的基本功能是先构造SUM语言的某句子的抽象语法树，然后将该语法树翻译成STACK的机器语言程序，并按顺序打印出该机器语言程序的指令。程序中有两段内容不完整（在程序中用TODO表示），请读懂并编译通过该程序，再将TODO的部分补充完整，并编译通过。 读懂程序sum.c并编译通过。（该程序可以使用gcc编译通过，其他编译环境请自行调试） 用你自己写的程序段替换程序中的TODO部分，使程序功能与实验内容的描述一致。 （此要求为额外要求，供学有余力的同学自行选择。）将程序的输入改为句子1+(2+3)的抽象语法树，尝试程序能否输出正确的结果。 实验参考 SUM语言简介：SUM语言是一种描述简单表达式的语言，该语言只有两种终结符num和+，其中num表示整型数，+表示加法。即该语言能表示整型的加法表达式。加法为左结合。 语言的文法为：E -&gt; num | E+E 栈式计算机STACK简介：这种机器有一个栈，能做的操作有两种，第一是向栈中压入一个整型数，第二是将栈顶的两个整型数弹出并做加法，然后将所得结果压入栈中。 因此，该计算机的机器语言只有两个指令，一为：PUSH n；（将整型数n压入栈中）；另一为：ADD；（无操作数，默认将栈顶的两个整型数弹出栈并相加，再将结果压入栈中）。 sum.c采用的翻译方法： SUM语言的句子先写成抽象语法树，然后对抽象语法树进行后续遍历，遍历到整型时就执行PUSH操作，遍历到+时就执行ADD操作。 SUM语言的句子翻译为STACK程序的例子： SUM语言的句子： 1+2+3 对应的抽象语法树: 12345 + / \ + 3 / \1 2 翻译成的STACK指令： ​ PUSH 1 ​ PUSH 2 ​ ADD ​ PUSH 3 ​ ADD 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TODO() \ do&#123; \ printf ("\nAdd your code here: file \"%s\", line %d\n", \ __FILE__, __LINE__); \ &#125;while(0)///////////////////////////////////////////////// Data structures for the Sum language.enum Exp_Kind_t &#123; EXP_INT, EXP_SUM &#125;;struct Exp_t &#123; enum Exp_Kind_t kind;&#125;;struct Exp_Int &#123; enum Exp_Kind_t kind; int i;&#125;;struct Exp_Sum &#123; enum Exp_Kind_t kind; struct Exp_t *left; struct Exp_t *right;&#125;;// "constructors"struct Exp_t *Exp_Int_new(int i) &#123; struct Exp_Int *p = (struct Exp_Int *)malloc(sizeof(*p)); p-&gt;kind = EXP_INT; p-&gt;i = i; return (struct Exp_t *)p;&#125;struct Exp_t *Exp_Sum_new(struct Exp_t *left, struct Exp_t *right) &#123; struct Exp_Sum *p = (struct Exp_Sum *)malloc(sizeof(*p)); p-&gt;kind = EXP_SUM; p-&gt;left = left; p-&gt;right = right; return (struct Exp_t *)p;&#125;// "printer"void Exp_print(struct Exp_t *exp) &#123; switch ( exp-&gt;kind ) &#123; case EXP_INT: &#123; struct Exp_Int *p = (struct Exp_Int *)exp; printf("%d ", p-&gt;i); break; &#125; case EXP_SUM: &#123; struct Exp_Sum *p = (struct Exp_Sum *)exp; Exp_print(p-&gt;left); printf("+ "); Exp_print(p-&gt;right); break; &#125; default: break; &#125;&#125;//////////////////////////////////////////////// Data structures for the Stack language.enum Stack_Kind_t &#123; STACK_ADD, STACK_PUSH &#125;;struct Stack_t &#123; enum Stack_Kind_t kind;&#125;;struct Stack_Add &#123; enum Stack_Kind_t kind;&#125;;struct Stack_Push &#123; enum Stack_Kind_t kind; int i;&#125;;// "printer"void Stack_print(struct Stack_t *stack) &#123; switch ( stack-&gt;kind ) &#123; case STACK_ADD: &#123; struct Stack_Add *p = (struct Stack_Add *)stack; printf("STACK_ADD\r\n"); break; &#125; case STACK_PUSH: &#123; struct Stack_Push *p = (struct Stack_Push *)stack; printf("STACK_PUSH %d\r\n", p-&gt;i); break; &#125; default: break; &#125;&#125;// "constructors"struct Stack_t *Stack_Add_new() &#123; struct Stack_Add *p = (struct Stack_Add *)malloc(sizeof(*p)); p-&gt;kind = STACK_ADD; return (struct Stack_t *)p;&#125;struct Stack_t *Stack_Push_new(int i) &#123; struct Stack_Push *p = (struct Stack_Push *)malloc(sizeof(*p)); p-&gt;kind = STACK_PUSH; p-&gt;i = i; return (struct Stack_t *)p;&#125;/// instruction liststruct List_t &#123; struct Stack_t *instr; struct List_t *next;&#125;;struct List_t *List_new(struct Stack_t *instr, struct List_t *next) &#123; struct List_t *p = (struct List_t *)malloc(sizeof(*p)); p-&gt;instr = instr; p-&gt;next = next; return p;&#125;// "printer"void List_reverse_print(struct List_t *list) &#123; struct List_t *next = NULL; struct List_t *reverse = NULL; struct List_t *cur = list; while ( cur != NULL ) &#123; next = cur-&gt;next; cur-&gt;next = reverse; reverse = cur; cur = next; &#125; //print printf("\n"); cur = reverse; while ( cur != NULL ) &#123; Stack_print(cur-&gt;instr); cur = cur-&gt;next; &#125;&#125;//////////////////////////////////////////////////// a compiler from Sum to Stackstruct List_t *all = 0;void emit(struct Stack_t *instr) &#123; all = List_new(instr, all);&#125;// 从抽象语法树 --&gt; 中间语言void compile(struct Exp_t *exp) &#123; switch ( exp-&gt;kind ) &#123; case EXP_INT: &#123; struct Exp_Int *p = (struct Exp_Int *)exp; emit(Stack_Push_new(p-&gt;i)); break; &#125; case EXP_SUM: &#123; struct Exp_Sum *p = (struct Exp_Sum *)exp; compile(p-&gt;left); compile(p-&gt;right); emit(Stack_Add_new()); break; &#125; default: break; &#125;&#125;//////////////////////////////////////////////////// program entryint main() &#123; printf("Compile starting\n"); // build an expression tree: // + // / \ // + 4 // / \ // 2 3 struct Exp_t *exp = Exp_Sum_new(Exp_Sum_new(Exp_Int_new(2) , Exp_Int_new(3)) , Exp_Int_new(4)); // print out this tree: printf("the expression is:\n"); Exp_print(exp); // compile this tree to Stack machine instructions compile(exp); // print out the generated Stack instructons: List_reverse_print(all); printf("\nCompile finished\n"); return 0;&#125; List_reverse_print 和 compile的case EXP_SUM为填充部分 实验结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证Yacc的使用]]></title>
    <url>%2F2019%2F05%2F11%2F%E9%AA%8C%E8%AF%81Yacc%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[实验内容 输入为一个布尔表达式，以换行结束。输出为这个布尔表达式的真值（true或false）。 尝试二义文法和非二义文法两种不同的实现方式。布尔表达式二义文法为：S –&gt; S or S | S and S | not S | (S) | true | false，其中优先级or &lt; and &lt; not，or 和 and 左结合，not 右结合。 非二义文法请参照表达式非二义文法自己写出来。 实验过程cal.l12345678910111213141516171819202122232425262728%&#123;#include "cal.tab.h"int yywrap(void)&#123; return 1;&#125;%&#125;delim [ \t ]ws &#123;delim&#125;+digit [0-9]num &#123;digit&#125;+%%0 &#123;return FALSE;&#125;&#123;num&#125; &#123;return TRUE;&#125;"+" &#123;return PLUS;&#125;"-" &#123;return MINUS;&#125;"*" &#123;return TIMES;&#125;"/" &#123;return DIVIDE;&#125;"||" &#123;return OR;&#125;"&amp;&amp;" &#123;return AND;&#125;"!" &#123;return NOT;&#125;"(" &#123;return LPAREN;&#125;")" &#123;return RPAREN;&#125;&#123;ws&#125; &#123;;&#125;"\n" &#123;return ENTER;&#125;. &#123;printf("\nLEX:ERROR! c=%s\n", yytext);&#125; 二义文法二义文法12345678910S –&gt; S or S | S and S | not S | (S) | true | false表示为：expr1 : expr1 OR expr1 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr1 AND expr1 &#123;$$ = ($1) ? ($3) : 0;&#125; | NOT expr1 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; 优先级123456%token NUM LPAREN RPAREN ENTER PLUS MINUS TIMES DIVIDE AND OR NOT TRUE FALSE%left OR%left AND%right NOT%left PLUS MINUS%left TIMES DIVIDE cal.y123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657%&#123; #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int yylex(); int yyerror(char* s); #define YYSTYPE double /* 将Yacc栈定义为double类型 */ #define YYDEBUG 1 /* 允许debug模式 */%&#125;%token NUM LPAREN RPAREN ENTER PLUS MINUS TIMES DIVIDE AND OR NOT TRUE FALSE%left OR%left AND%right NOT%left PLUS MINUS%left TIMES DIVIDE%% /* 这样写prog可以让分析器每次读入一行进行分析，下一行重新分析expr */prog : prog expln | expln ;expln : expr ENTER &#123;if($$) printf("true\n");else printf("false\n");&#125; ; expr : expr PLUS term &#123;$$ = $1 + $3;&#125; | expr MINUS term &#123;$$ = $1 - $3;&#125; | term ; term : term TIMES factor &#123;$$ = $1 * $3;&#125; | term DIVIDE factor &#123;$$ = $1 / $3;&#125; | factor ; factor : LPAREN expr RPAREN &#123;$$ = $2;&#125; | MINUS factor &#123;$$ = - $2;&#125; | NUM &#123;$$ = $1;&#125; | expr1 ;expr1 : expr1 OR expr1 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr1 AND expr1 &#123;$$ = ($1) ? ($3) : 0;&#125; | NOT expr1 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; %%int main()&#123; // yydebug = 1; yyparse(); return 0;&#125; 非二义文法非二义文法12345678910111213141516E -&gt; E OR T | TT -&gt; T AND F | FF -&gt; NOT F | (F) | true | falseexpr1 : expr1 OR expr2 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr2 ;expr2 : expr2 AND expr3 &#123;$$ = ($1) ? ($3) : 0;&#125; | expr3 ;expr3 : NOT expr3 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; cal.y123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263%&#123; #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int yylex(); int yyerror(char* s); #define YYSTYPE double /* 将Yacc栈定义为double类型 */ #define YYDEBUG 1 /* 允许debug模式 */%&#125;%token NUM LPAREN RPAREN ENTER PLUS MINUS TIMES DIVIDE AND OR NOT TRUE FALSE%left OR%left AND%right NOT%left PLUS MINUS%left TIMES DIVIDE%% /* 这样写prog可以让分析器每次读入一行进行分析，下一行重新分析expr */prog : prog expln | expln ;expln : expr ENTER &#123;if($$) printf("true\n");else printf("false\n");&#125; ; expr : expr PLUS term &#123;$$ = $1 + $3;&#125; | expr MINUS term &#123;$$ = $1 - $3;&#125; | term ; term : term TIMES factor &#123;$$ = $1 * $3;&#125; | term DIVIDE factor &#123;$$ = $1 / $3;&#125; | factor ; factor : LPAREN expr RPAREN &#123;$$ = $2;&#125; | MINUS factor &#123;$$ = - $2;&#125; | NUM &#123;$$ = $1;&#125; | expr1 ;expr1 : expr1 OR expr2 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr2 ;expr2 : expr2 AND expr3 &#123;$$ = ($1) ? ($3) : 0;&#125; | expr3 ;expr3 : NOT expr3 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; %%int main()&#123; // yydebug = 1; yyparse(); return 0;&#125; makefile1234567891011121314151617181920cal3: cal.tab.o lex.yy.o gcc -o cal3 cal.tab.o lex.yy.o -lylex.yy.o: lex.yy.c cal.tab.h gcc -c lex.yy.ccal.tab.o: cal.tab.c gcc -c cal.tab.clex.yy.c: cal.l flex cal.lcal.tab.c: cal.y bison -dv cal.ycal.tab.h: cal.y echo "cal.tab.h was created at the same time as cal.tab.c."clean: rm -f cal3.exe lex.yy.o cal.tab.o lex.yy.c cal.tab.c cal.tab.h cal3.exe.stackdump cal.output 实验结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Lex设计词法分析器]]></title>
    <url>%2F2019%2F05%2F11%2F%E7%94%A8Lex%E8%AE%BE%E8%AE%A1%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实验内容Exp2使用lex为下述文法语言写一个词法分析器。 &lt;程序&gt; -&gt; PROGRAM &lt;标识符&gt; ; &lt;分程序&gt;&lt;分程序&gt; -&gt; &lt;变量说明&gt; BEGIN &lt;语句表&gt; END.&lt;变量说明&gt; -&gt; VAR &lt;变量说明表&gt;;&lt;变量说明表&gt; -&gt;&lt;变量表&gt;: &lt;类型&gt; | &lt;变量表&gt;: &lt;类型&gt;; &lt;变量说明表&gt;&lt;类型&gt;- &gt; INTEGER | REAL&lt;变量表&gt; -&gt; &lt;变量&gt; | &lt;变量&gt;, &lt;变量表&gt;&lt;语句表&gt; -&gt; &lt;语句&gt; | &lt;语句&gt;; &lt;语句表&gt;&lt;语句&gt; -&gt; &lt;赋值语句&gt; | &lt;条件语句&gt; | | &lt;复合语句&gt;&lt;赋值语句&gt; -&gt; &lt;变量&gt; := &lt;算术表达式&gt;&lt;条件语句&gt; -&gt; IF &lt;关系表达式&gt; THEN &lt;语句&gt; ELSE &lt;语句&gt; -&gt; WHILE &lt;关系表达式&gt; DO &lt;语句&gt;&lt;复合语句&gt; -&gt; BEGIN &lt;语句表&gt; END&lt;算术表达式&gt; -&gt; &lt;项&gt; | &lt;算术表达式&gt; + &lt;项&gt; | &lt;算术表达式&gt; - &lt;项&gt;&lt;项&gt; -&gt; &lt;因式&gt; | &lt;项&gt; * &lt;因式&gt; | &lt;项&gt; / &lt;因式&gt;&lt;因式&gt; -&gt; &lt;变量&gt; | &lt;常数&gt; | (&lt;算术表达式&gt;)&lt;关系表达式&gt; -&gt; &lt;算术表达式&gt; &lt;关系符&gt; &lt;算术表达式&gt;&lt;变量&gt; -&gt; &lt;标识符&gt;&lt;标识符&gt; -&gt; &lt;标识符&gt;&lt;字母&gt; | &lt;标识符&gt;&lt;数字&gt; | &lt;字母&gt;&lt;常数&gt; -&gt; &lt;整数&gt; | &lt;浮点数&gt;&lt;整数&gt; -&gt; &lt;数字&gt; | &lt;数字&gt; &lt;整数&gt;&lt;浮点数&gt; -&gt; .&lt;整数&gt; | &lt;整数&gt;.&lt;整数&gt;&lt;关系符&gt; -&gt; &lt; | &lt;= | = | &gt; | &gt;=| &lt;&gt;&lt;字母&gt; -&gt; A | B | …| X | Y | Z | a | b | …| x | y | z&lt;数字&gt; -&gt; 0|1|2|…|9 Exp3 要求每次调用词法分析函数yylex时，只返回一个记号(token)； 为记号选择适当的属性值，并且每次词法分析函数返回记号前，都将记号的属性值存入全局变量yylval中。（yylval可以自己定义为全局变量）； 记号属性值的选择：标识符的属性为标识符的名字字符串（例如，标识符name1的属性为字符串”name1”），整数的属性为整数值，浮点数的属性为浮点数值。其他记号属性值可自己选择。关键字可以省略属性。 注意：由于属性值需要存入yylval中，并且记号属性值的类型比较多（可能为字符串、整数、浮点数等），因此yylval必须能同时存放各种类型的值（提示：将yylval设置为union类型）。 在cygwin下用flex和gcc工具将实验调试通过，并能通过例子parser0中testcases目录下的test1.p测试例的测试。 实验过程添加记号名12345678910#define PROGRAM 36#define BEGIN1 37#define VAR 38#define THEN 39#define INT 40#define FLOAT 41#define END 42#define REAL 43#define COMMA 44#define COLON 45 正规定义12345int &#123;digit&#125;+(E[+-]?&#123;digit&#125;+)?float &#123;digit&#125;*(\.&#123;digit&#125;+)(E[+-]?&#123;digit&#125;+)? allow ((\\\\)|(\\\")|(\\\')|(\\&#123;letter&#125;)|(\\&#123;digit&#125;))*str (&#123;allow&#125;|[^\"\'\n\\])*\"end END|END. 定义yylval12345union data&#123; int inum; float fnum; char c[20];&#125;yylval; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/* 把讨厌的注释去掉 */%&#123;#include &lt;stdio.h&gt; #define LT 1#define LE 2#define GT 3#define GE 4#define EQ 5#define NE 6#define WHILE 18#define DO 19#define ID 20//#define NUMBER 21#define RELOP 22#define NEWLINE 23#define ERRORCHAR 24#define LEFTBRACKET 25#define RIGHTBRACKET 26#define SEMICOLON 27#define ASSIGN 28#define ARITHMETIC 29#define NOTE 30#define IF 31#define ELSE 32#define LEFTBRACES 33#define RIGHTBRACES 34#define STRING 35#define STRERROR 46#define PROGRAM 36#define BEGIN1 37#define VAR 38#define THEN 39#define INT 40#define FLOAT 41#define END 42#define REAL 43#define COMMA 44#define COLON 45union data&#123; int inum; float fnum; char c[20];&#125;yylval;%&#125;underline [_] delim [ \t \n]ws &#123;delim&#125;+letter [A-Za-z]digit [0-9]id &#123;underline&#125;*&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*int &#123;digit&#125;+(E[+-]?&#123;digit&#125;+)?float &#123;digit&#125;*(\.&#123;digit&#125;+)(E[+-]?&#123;digit&#125;+)? allow ((\\\\)|(\\\")|(\\\')|(\\&#123;letter&#125;)|(\\&#123;digit&#125;))*str (&#123;allow&#125;|[^\"\'\n\\])*\"end END|END./* 状态（或条件）定义可以定义在这里 * INITIAL是一个默认的状态，不需要定义 */%s COMMENT%s NOTE1%s QUOTE%%&lt;INITIAL&gt;"/*" &#123;BEGIN COMMENT;&#125;&lt;COMMENT&gt;"*/" &#123;BEGIN INITIAL;&#125;&lt;COMMENT&gt;.|\n &#123;;&#125;&lt;INITIAL&gt;"//" &#123;BEGIN NOTE1;&#125;&lt;NOTE1&gt;\n &#123;BEGIN INITIAL;&#125;&lt;NOTE1&gt;. &#123;;&#125;&lt;INITIAL&gt;"\"" &#123;BEGIN QUOTE;&#125;&lt;QUOTE&gt;"\"" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;"\n" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;&#123;str&#125; &#123;BEGIN INITIAL; return (STRING);&#125;&lt;QUOTE&gt;[^\"\n] &#123;;&#125;&lt;INITIAL&gt;&#123;ws&#125; &#123;;&#125;&lt;INITIAL&gt;PROGRAM &#123;return (PROGRAM);&#125;&lt;INITIAL&gt;BEGIN &#123;return (BEGIN1);&#125;&lt;INITIAL&gt;&#123;end&#125; &#123;return (END);&#125;&lt;INITIAL&gt;WHILE &#123;return (WHILE);&#125;&lt;INITIAL&gt;DO &#123;return (DO);&#125;&lt;INITIAL&gt;IF &#123;return (IF);&#125;&lt;INITIAL&gt;THEN &#123;return (THEN);&#125;&lt;INITIAL&gt;ELSE &#123;return (ELSE);&#125;&lt;INITIAL&gt;while &#123;return (WHILE);&#125;&lt;INITIAL&gt;do &#123;return (DO);&#125;&lt;INITIAL&gt;if &#123;return (IF);&#125;&lt;INITIAL&gt;else &#123;return (ELSE);&#125;&lt;INITIAL&gt;then &#123;return (THEN);&#125;&lt;INITIAL&gt;VAR &#123;return (VAR);&#125;&lt;INITIAL&gt;&#123;int&#125; &#123;sscanf(yytext,"%d",&amp;yylval.inum); return (INT);&#125;&lt;INITIAL&gt;&#123;float&#125; &#123;sscanf(yytext,"%f",&amp;yylval.fnum); return (FLOAT);&#125;&lt;INITIAL&gt;REAL &#123;return (REAL);&#125;&lt;INITIAL&gt;&#123;id&#125; &#123;sscanf(yytext,"%s",&amp;yylval.c); return (ID);&#125;&lt;INITIAL&gt;"&lt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&lt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"==" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"!=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"(" &#123;return (LEFTBRACKET);&#125;&lt;INITIAL&gt;")" &#123;return (RIGHTBRACKET);&#125;&lt;INITIAL&gt;"&#123;" &#123;return (LEFTBRACES);&#125;&lt;INITIAL&gt;"&#125;" &#123;return (RIGHTBRACES);&#125;&lt;INITIAL&gt;";" &#123;return (SEMICOLON);&#125;&lt;INITIAL&gt;"=" &#123;return (ASSIGN);&#125;&lt;INITIAL&gt;":=" &#123;return (ASSIGN);&#125;&lt;INITIAL&gt;":" &#123;return (COLON);&#125;&lt;INITIAL&gt;"+" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"-" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"*" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"/" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"," &#123;return (COMMA);&#125;&lt;INITIAL&gt;. &#123;return ERRORCHAR;&#125;%%int yywrap ()&#123; return 1;&#125;void writeout(int c)&#123; switch(c)&#123; case ERRORCHAR: fprintf(yyout, "(ERRORCHAR, \"%s\") ", yytext);break; case PROGRAM: fprintf(yyout, "(PROGRAM, \"%s\") ", yytext);break; case BEGIN1: fprintf(yyout, "(BEGIN, \"%s\") ", yytext);break; case END: fprintf(yyout, "(END, \"%s\") ", yytext);break; case IF: fprintf(yyout, "(IF, \"%s\") ", yytext);break; case THEN: fprintf(yyout, "(THEN, \"%s\") ", yytext);break; case ELSE: fprintf(yyout, "(ELSE, \"%s\") ", yytext);break; case VAR: fprintf(yyout, "(VAR, \"%s\") ", yytext);break; case INT: fprintf(yyout, "(INT, \"%s\") ", yytext);break; case FLOAT: fprintf(yyout, "(FLOAT, \"%s\") ", yytext);break; case REAL: fprintf(yyout, "(REAL, \"%s\") ", yytext);break; case COMMA: fprintf(yyout, "(COMMA, \"%s\") ", yytext);break; case COLON: fprintf(yyout, "(COLON, \"%s\") ", yytext);break; case RELOP: fprintf(yyout, "(RELOP, \"%s\") ", yytext);break; case WHILE: fprintf(yyout, "(WHILE, \"%s\") ", yytext);break; case DO: fprintf(yyout, "(DO, \"%s\") ", yytext);break; case ID: fprintf(yyout, "(ID, \"%s\") ", yytext);break; case LEFTBRACKET: fprintf(yyout, "(LEFTBRACKET, \"%s\") ", yytext);break; case RIGHTBRACKET: fprintf(yyout, "(RIGHTBRACKET, \"%s\") ", yytext);break; case LEFTBRACES: fprintf(yyout, "(LEFTBRACES, \"%s\") ", yytext);break; case RIGHTBRACES: fprintf(yyout, "(RIGHTBRACES, \"%s\") ", yytext);break; case SEMICOLON: fprintf(yyout, "(SEMICOLON, \"%s\") ", yytext);break; case ASSIGN: fprintf(yyout, "(ASSIGN, \"%s\") ", yytext);break; case ARITHMETIC: fprintf(yyout, "(ARITHMETIC, \"%s\") ", yytext);break; case NOTE: fprintf(yyout, "(NOTE, \"%s\") ", yytext);break; case NEWLINE: fprintf(yyout, "\n");break; case STRING: fprintf(yyout, "(STRING, \"%s\") ", yytext);break; default:break; &#125; return;&#125;int main (int argc, char ** argv)&#123; int c,j=0; if (argc&gt;=2)&#123; if ((yyin = fopen(argv[1], "r")) == NULL)&#123; printf("Can't open file %s\n", argv[1]); return 1; &#125; if (argc&gt;=3)&#123; yyout=fopen(argv[2], "w"); &#125; &#125; while (c = yylex())&#123; writeout(c); j++; if (j%5 == 0) writeout(NEWLINE); &#125; if(argc&gt;=2)&#123; fclose(yyin); if (argc&gt;=3) fclose(yyout); &#125; return 0;&#125; 实验结果测试样例 运行结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cygwin环境的熟悉和lex的使用1]]></title>
    <url>%2F2019%2F05%2F11%2FCygwin%E7%8E%AF%E5%A2%83%E7%9A%84%E7%86%9F%E6%82%89%E5%92%8Clex%E7%9A%84%E4%BD%BF%E7%94%A81%2F</url>
    <content type="text"><![CDATA[实验内容Exp1读懂exam1.l和exam2.l两个例子，使用cygwin下的flex工具将exam1.l和exam2.l编译并调试通过。并且修改exam2.l，在其基础上增加如下记号： 左右大小括号：{ } ( ) 将关系算符改写成C中的形式 分号、赋值号：; = 关键字：if else 双斜线表示的注释：// 算术运算符号：+ - * / 将标识符改为可含有下划线，并且可以以下划线开头 将注释内容忽略 Exp e1在实验1所改写的程序的基础上增加识别string记号。string是字符串，如果”出现在字符串中，则必须转义，写成\”形式；如果\出现在字符串中，也必须转义，写成\形式。 在cygwin下用flex和gcc工具将实验调试通过，并写出测试例测试正确性。同时该实验必须满足如下要求： string是字符串，它是以双引号括起的一串字符。 双引号内的字符有如下要求： 不能包含单独的”或者\，除非用\进行转义。例如字符串内的”写成\”，而\写成\。 字符串内可以出现转义字符。转义字符可简化表示为\c，其中c为任意字母或(反斜杠),”（双引号）,’（单引号）三个符号中的一个。 字符串内不可包含实体的换行。（可以包含\n，但是如果两个“”中的字符串出现在两行中，即包含了实体换行，则不应识别为字符串） 实验过程Exp1添加记号名12345678910111213#define NEWLINE 23#define ERRORCHAR 24#define LEFTBRACKET 25 //bracket 为小括号 ： （）#define RIGHTBRACKET 26#define SEMICOLON 27 //分号#define ASSIGN 28 //赋值#define ARITHMETIC 29 //算术#define NOTE 30 注释#define IF 31#define ELSE 32#define LEFTBRACES 33 //braces 为大括号 ： &#123; &#125;#define RIGHTBRACES 34 定义动作123456789101112131415161718&lt;INITIAL&gt;"&lt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&lt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"==" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"!=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"(" &#123;return (LEFTBRACKET);&#125;&lt;INITIAL&gt;")" &#123;return (RIGHTBRACKET);&#125;&lt;INITIAL&gt;"&#123;" &#123;return (LEFTBRACES);&#125;&lt;INITIAL&gt;"&#125;" &#123;return (RIGHTBRACES);&#125;&lt;INITIAL&gt;";" &#123;return (SEMICOLON);&#125;&lt;INITIAL&gt;"=" &#123;return (ASSIGN);&#125;&lt;INITIAL&gt;"+" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"-" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"*" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"/" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;. &#123;return ERRORCHAR;&#125; 更改writeout函数1234567891011121314151617181920212223void writeout(int c)&#123; switch(c)&#123; case ERRORCHAR: fprintf(yyout, "(ERRORCHAR, \"%s\") ", yytext);break; case RELOP: fprintf(yyout, "(RELOP, \"%s\") ", yytext);break; case WHILE: fprintf(yyout, "(WHILE, \"%s\") ", yytext);break; case DO: fprintf(yyout, "(DO, \"%s\") ", yytext);break; case NUMBER: fprintf(yyout, "(NUM, \"%s\") ", yytext);break; case ID: fprintf(yyout, "(ID, \"%s\") ", yytext);break; case LEFTBRACKET: fprintf(yyout, "(LEFTBRACKET, \"%s\") ", yytext);break; case RIGHTBRACKET: fprintf(yyout, "(RIGHTBRACKET, \"%s\") ", yytext);break; case LEFTBRACES: fprintf(yyout, "(LEFTBRACES, \"%s\") ", yytext);break; case RIGHTBRACES: fprintf(yyout, "(RIGHTBRACES, \"%s\") ", yytext);break; case SEMICOLON: fprintf(yyout, "(SEMICOLON, \"%s\") ", yytext);break; case ASSIGN: fprintf(yyout, "(ASSIGN, \"%s\") ", yytext);break; case ARITHMETIC: fprintf(yyout, "(ARITHMETIC, \"%s\") ", yytext);break; case NOTE: fprintf(yyout, "(NOTE, \"%s\") ", yytext);break; case IF: fprintf(yyout, "(IF, \"%s\") ", yytext);break; case ELSE: fprintf(yyout, "(ELSE, \"%s\") ", yytext);break; case NEWLINE: fprintf(yyout, "\n");break; default:break; &#125; return;&#125; Exp e1增加String记号12#define STRING 35#define STRERROR 36 进行正规定义12allow ((\\\\)|(\\\")|(\\\')|(\\&#123;letter&#125;)|(\\&#123;digit&#125;))*str (&#123;allow&#125;|[^\"\'\n\\])*\" 增加引用状态12345&lt;INITIAL&gt;"\"" &#123;BEGIN QUOTE;&#125;&lt;QUOTE&gt;"\"" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;"\n" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;&#123;str&#125; &#123;BEGIN INITIAL; return (STRING);&#125;&lt;QUOTE&gt;[^\"\n] &#123;;&#125; QUOTE状态以双引号开始，双引号结束，当匹配到除字符串str和单引号、回车之外的任意字符，返回ERRORCHAR 当QUOTE状态下，遇到回车则进入INITIAL状态 实验结果编译运行123flex exam2.lettergcc lex.yy.c -lfl./a.out test2.p 对于不满足string条件的STRERROR直接不输出 对于string6 , 在本分析器中当遇到第一个双引号时，进入QUOTE状态，之后string6”被识别为str类型，但虽然str以双引号结尾，但不将双引号作为字符串的一部分，（如果string6”被作为字符串的话，string6””应该被识别为str类型） 之后，QUOTE状态结束，遇到双引号又进入QUOTE状态，遇到回车，结束QUOTE状态 对于string2 ， string3: ​ allow ((\\\\)|(\\\&quot;)|(\\\&#39;)|(\\{letter})|(\\{digit}))* ​ “ \ ”、“ \” ”属于allow范围，因此包含在字符串内 对于string4: “\n \’ \0 \a”均属于allow范围，包含在字符串内 对于string5，string7，string，8，没有匹配到合适的str类型，因此匹配到的STRERROR类型不输出，最后不会有输出结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[新建仓库新建名为 yourgithubname.github.io 的仓库 Git Nodejs直接官网安装 Git 、Nodejs 配置SSH-KEYssh-keygen -t rsa -C &quot;邮件地址&quot; 连续三次回车，会生成key在用户文件目录下，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的 github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： $ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 测试KEY$ ssh -T git@github.com 邮箱地址不用换 如果看到 Hi XX! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 证明已经成功 Host key verification failed如果提示 Host key verification failed ， 输入 ssh-keyscan -H github.com &gt;&gt; ~/.ssh/known_hosts 之后重新测试 npm install hexo安装hexo]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理-图像合成]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[图像分割选择特定拓展名12345678img_path = &apos;pics/&apos;;ext = &#123;&apos;*.jpeg&apos;,&apos;*.jpg&apos;,&apos;*.png&apos;&#125;;img_list = [];for i = 1:numel(ext) img_list = [img_list ; dir(fullfile(img_path,ext&#123;i&#125;))];endimg_num = length(img_list); 转换为特定尺寸的灰度图像1234567891011if img_num &gt; 0 for j = 1 : img_num img_name = img_list(j).name; img = imread(strcat(img_path,img_name)); img = imresize(img,[640 480]); G = rgb2gray(img); strname = strsplit(img_name,&apos;.&apos;); name = strname&#123;1,1&#125;; imwrite(G , strcat(img_path, name , &apos;.gif&apos;)); endend 求素材图片的RGB平均值123456789101112131415161718192021SIZE = 5;img_RGB = zeros(img_num,SIZE,SIZE,3);average_rgb = zeros(img_num,3);if img_num &gt; 0 for j = 1:img_num img_name = img_list(j).name; img = imread(strcat(img_path,img_name)); img = imresize(img,[SIZE SIZE]); img_RGB(j,:,:,:) = img; R = img(:,:,1); G = img(:,:,2); B = img(:,:,3); average_rgb(j,1)=mean(mean(R)); average_rgb(j,2)=mean(mean(G)); average_rgb(j,3)=mean(mean(B)); endend 替换为素材图片123456789101112131415161718192021222324252627original_Img = (&apos;original.png&apos;);Image_size = size(original_Img);Image_RGB = zeros(Image_size(1),Image_size(2),3);Image_RGB = original_Img(:,:,:);for row = 1 : SIZE :Image_size(1)-SIZE for col = 1 : SIZE :Image_size(2)-SIZE rgb_mean = zeros(3); for k = 1:3 temp = original_Img(row:row+SIZE-1 ,col:col+SIZE-1,k); rgb_mean(k) = mean(mean(temp)); end deviation = zeros(1,img_num); for k = 1:img_num deviation(k) = abs(average_rgb(k,1) - rgb_mean(1)) + abs(average_rgb(k,2) - rgb_mean(2)) + abs(average_rgb(k,3) - rgb_mean(3)); 求目标区域与每一个素材图片的RGB误差 end [min_value,min_position] = min(deviation); %得到最小值下标 Image_RGB(row:row+SIZE-1 ,col:col+SIZE-1,:) = img_RGB(min_position,:,:,:); endendImage_RGB = uint8(Image_RGB);imwrite(Image_RGB,&apos;0.jpg&apos;); 实验结果素材图片 original pic After]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI-02深度学习概述]]></title>
    <url>%2F2019%2F03%2F04%2FAI-02%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[M-P神经元 为什么需要激活函数 激活函数举例 权重人工设置m-p神经元的权重由人工设置，无法学习 单层感知器首个可以学习的神经网络 逻辑实现 多层感知器异或 单层感知器，无法实现异或关系，无法找到一条线完美分开数据（0、1） 同或 单隐层神经网络可视化urlhttp://playground.tensorflow.org/ 万有逼近定理 双隐层感知器 神经网络每一层作用 更深 or 更宽]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI_01人工智能概述]]></title>
    <url>%2F2019%2F03%2F04%2FAI-01%2F</url>
    <content type="text"><![CDATA[人工智能&amp;机器学习什么是人工智能人工智能(Artificial Intelligence)使一部机器像人一样进行感知、认知、决策、执行的人工程序或系统 标志性事件 人工智能发展阶段 人工智能三个层面计算智能能存能算 感知智能能听会说、能看会认 认知智能能理解、会思考 人工智能 &gt; 机器学习 &gt; 深度学习 逻辑演绎 vs 归纳总结 专家系统根据专家定义的知识和经验，进行推理和判断，从而模拟人类专家的决策过程来解决问题。 知识工程 vs 机器学习 计算机视觉人脸识别图像分类目标检测图像搜索图像分割视频监控语音技术语音识别语音合成声纹识别自然语言处理文本分类机器翻译知识图谱自动问答信息检索文本生成机器学习的定义最常用定义计算机系统能够利用经验提高自身的性能 可操作定义机器学习本质是一个基于经验数据的函数估计问题 统计学定义提取重要模式、趋势，并理解数据，即从数据中学习 机器学习-怎么学模型对要学习问题映射的假设（问题建模，确定假设空间） 模型分类数据标记 监督学习模型 无监督学习模型 数据分布参数模型 、 无参数模型 建模对象 判别模型 生成模型 策略从假设空间中学习/选择最优模型的准则（确定目标函数） 算法根据目标函数求解最优模型的具体计算方法（求解模型参数） 深度学习传统机器学习：人工设计特征 传统机器学习VS 深度学习 手动设计程序 手动设计特征 神经网络结构发展 深度学习的不能 连接主义 vs 符号主义 从对立到合作 连接主义+ 符号主义]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题Google验证]]></title>
    <url>%2F2019%2F02%2F23%2Fhexo-google-verify%2F</url>
    <content type="text"><![CDATA[Google验证urlhttps://www.google.com/webmasters 修改配置文件使用html标签验证，方法同baidu验证 在站点配置文件中添加 google_site_verification: 123xxxxxx321 使用hexo d提交，刷新页面，查看源代码，如果能看到一下内容，证明标签已经成功添加： 进行验证 添加sitemap添加sitemap]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo_image]]></title>
    <url>%2F2019%2F02%2F19%2Fhexo-image%2F</url>
    <content type="text"><![CDATA[hexo md文档添加图片修改站点配置文件post_asset_folder 字段置为true 修改后，当进入到/source/_posts 下使用 hexo n xxx 建立新的文章时，会自动生成一个相同命名的文件夹，用于存放文章中引用的图片等资源， 在md文档中引用时，使用相对路径 插件安装安装插件 使用命令 npm install https://github.com/CodeFalling/hexo-asset-image --save 保存预览hexo g hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
