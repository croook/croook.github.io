<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[语言SUM到栈式计算机STACK的机器语言的翻译]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%AF%AD%E8%A8%80SUM%E5%88%B0%E6%A0%88%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%9C%BASTACK%E7%9A%84%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[实验内容sum.c是用c语言写的从sum语言到栈式计算机STACK的机器语言的编译器（省略了词法语法分析部分）。该程序的基本功能是先构造SUM语言的某句子的抽象语法树，然后将该语法树翻译成STACK的机器语言程序，并按顺序打印出该机器语言程序的指令。程序中有两段内容不完整（在程序中用TODO表示），请读懂并编译通过该程序，再将TODO的部分补充完整，并编译通过。 读懂程序sum.c并编译通过。（该程序可以使用gcc编译通过，其他编译环境请自行调试） 用你自己写的程序段替换程序中的TODO部分，使程序功能与实验内容的描述一致。 （此要求为额外要求，供学有余力的同学自行选择。）将程序的输入改为句子1+(2+3)的抽象语法树，尝试程序能否输出正确的结果。 实验参考 SUM语言简介：SUM语言是一种描述简单表达式的语言，该语言只有两种终结符num和+，其中num表示整型数，+表示加法。即该语言能表示整型的加法表达式。加法为左结合。 语言的文法为：E -&gt; num | E+E 栈式计算机STACK简介：这种机器有一个栈，能做的操作有两种，第一是向栈中压入一个整型数，第二是将栈顶的两个整型数弹出并做加法，然后将所得结果压入栈中。 因此，该计算机的机器语言只有两个指令，一为：PUSH n；（将整型数n压入栈中）；另一为：ADD；（无操作数，默认将栈顶的两个整型数弹出栈并相加，再将结果压入栈中）。 sum.c采用的翻译方法： SUM语言的句子先写成抽象语法树，然后对抽象语法树进行后续遍历，遍历到整型时就执行PUSH操作，遍历到+时就执行ADD操作。 SUM语言的句子翻译为STACK程序的例子： SUM语言的句子： 1+2+3 对应的抽象语法树: 12345 + / \ + 3 / \1 2 翻译成的STACK指令： ​ PUSH 1 ​ PUSH 2 ​ ADD ​ PUSH 3 ​ ADD 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define TODO() \ do&#123; \ printf ("\nAdd your code here: file \"%s\", line %d\n", \ __FILE__, __LINE__); \ &#125;while(0)///////////////////////////////////////////////// Data structures for the Sum language.enum Exp_Kind_t &#123; EXP_INT, EXP_SUM &#125;;struct Exp_t &#123; enum Exp_Kind_t kind;&#125;;struct Exp_Int &#123; enum Exp_Kind_t kind; int i;&#125;;struct Exp_Sum &#123; enum Exp_Kind_t kind; struct Exp_t *left; struct Exp_t *right;&#125;;// "constructors"struct Exp_t *Exp_Int_new(int i) &#123; struct Exp_Int *p = (struct Exp_Int *)malloc(sizeof(*p)); p-&gt;kind = EXP_INT; p-&gt;i = i; return (struct Exp_t *)p;&#125;struct Exp_t *Exp_Sum_new(struct Exp_t *left, struct Exp_t *right) &#123; struct Exp_Sum *p = (struct Exp_Sum *)malloc(sizeof(*p)); p-&gt;kind = EXP_SUM; p-&gt;left = left; p-&gt;right = right; return (struct Exp_t *)p;&#125;// "printer"void Exp_print(struct Exp_t *exp) &#123; switch ( exp-&gt;kind ) &#123; case EXP_INT: &#123; struct Exp_Int *p = (struct Exp_Int *)exp; printf("%d ", p-&gt;i); break; &#125; case EXP_SUM: &#123; struct Exp_Sum *p = (struct Exp_Sum *)exp; Exp_print(p-&gt;left); printf("+ "); Exp_print(p-&gt;right); break; &#125; default: break; &#125;&#125;//////////////////////////////////////////////// Data structures for the Stack language.enum Stack_Kind_t &#123; STACK_ADD, STACK_PUSH &#125;;struct Stack_t &#123; enum Stack_Kind_t kind;&#125;;struct Stack_Add &#123; enum Stack_Kind_t kind;&#125;;struct Stack_Push &#123; enum Stack_Kind_t kind; int i;&#125;;// "printer"void Stack_print(struct Stack_t *stack) &#123; switch ( stack-&gt;kind ) &#123; case STACK_ADD: &#123; struct Stack_Add *p = (struct Stack_Add *)stack; printf("STACK_ADD\r\n"); break; &#125; case STACK_PUSH: &#123; struct Stack_Push *p = (struct Stack_Push *)stack; printf("STACK_PUSH %d\r\n", p-&gt;i); break; &#125; default: break; &#125;&#125;// "constructors"struct Stack_t *Stack_Add_new() &#123; struct Stack_Add *p = (struct Stack_Add *)malloc(sizeof(*p)); p-&gt;kind = STACK_ADD; return (struct Stack_t *)p;&#125;struct Stack_t *Stack_Push_new(int i) &#123; struct Stack_Push *p = (struct Stack_Push *)malloc(sizeof(*p)); p-&gt;kind = STACK_PUSH; p-&gt;i = i; return (struct Stack_t *)p;&#125;/// instruction liststruct List_t &#123; struct Stack_t *instr; struct List_t *next;&#125;;struct List_t *List_new(struct Stack_t *instr, struct List_t *next) &#123; struct List_t *p = (struct List_t *)malloc(sizeof(*p)); p-&gt;instr = instr; p-&gt;next = next; return p;&#125;// "printer"void List_reverse_print(struct List_t *list) &#123; struct List_t *next = NULL; struct List_t *reverse = NULL; struct List_t *cur = list; while ( cur != NULL ) &#123; next = cur-&gt;next; cur-&gt;next = reverse; reverse = cur; cur = next; &#125; //print printf("\n"); cur = reverse; while ( cur != NULL ) &#123; Stack_print(cur-&gt;instr); cur = cur-&gt;next; &#125;&#125;//////////////////////////////////////////////////// a compiler from Sum to Stackstruct List_t *all = 0;void emit(struct Stack_t *instr) &#123; all = List_new(instr, all);&#125;// 从抽象语法树 --&gt; 中间语言void compile(struct Exp_t *exp) &#123; switch ( exp-&gt;kind ) &#123; case EXP_INT: &#123; struct Exp_Int *p = (struct Exp_Int *)exp; emit(Stack_Push_new(p-&gt;i)); break; &#125; case EXP_SUM: &#123; struct Exp_Sum *p = (struct Exp_Sum *)exp; compile(p-&gt;left); compile(p-&gt;right); emit(Stack_Add_new()); break; &#125; default: break; &#125;&#125;//////////////////////////////////////////////////// program entryint main() &#123; printf("Compile starting\n"); // build an expression tree: // + // / \ // + 4 // / \ // 2 3 struct Exp_t *exp = Exp_Sum_new(Exp_Sum_new(Exp_Int_new(2) , Exp_Int_new(3)) , Exp_Int_new(4)); // print out this tree: printf("the expression is:\n"); Exp_print(exp); // compile this tree to Stack machine instructions compile(exp); // print out the generated Stack instructons: List_reverse_print(all); printf("\nCompile finished\n"); return 0;&#125; List_reverse_print 和 compile的case EXP_SUM为填充部分 实验结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证Yacc的使用]]></title>
    <url>%2F2019%2F05%2F11%2F%E9%AA%8C%E8%AF%81Yacc%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[实验内容 输入为一个布尔表达式，以换行结束。输出为这个布尔表达式的真值（true或false）。 尝试二义文法和非二义文法两种不同的实现方式。布尔表达式二义文法为：S –&gt; S or S | S and S | not S | (S) | true | false，其中优先级or &lt; and &lt; not，or 和 and 左结合，not 右结合。 非二义文法请参照表达式非二义文法自己写出来。 实验过程cal.l12345678910111213141516171819202122232425262728%&#123;#include "cal.tab.h"int yywrap(void)&#123; return 1;&#125;%&#125;delim [ \t ]ws &#123;delim&#125;+digit [0-9]num &#123;digit&#125;+%%0 &#123;return FALSE;&#125;&#123;num&#125; &#123;return TRUE;&#125;"+" &#123;return PLUS;&#125;"-" &#123;return MINUS;&#125;"*" &#123;return TIMES;&#125;"/" &#123;return DIVIDE;&#125;"||" &#123;return OR;&#125;"&amp;&amp;" &#123;return AND;&#125;"!" &#123;return NOT;&#125;"(" &#123;return LPAREN;&#125;")" &#123;return RPAREN;&#125;&#123;ws&#125; &#123;;&#125;"\n" &#123;return ENTER;&#125;. &#123;printf("\nLEX:ERROR! c=%s\n", yytext);&#125; 二义文法二义文法12345678910S –&gt; S or S | S and S | not S | (S) | true | false表示为：expr1 : expr1 OR expr1 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr1 AND expr1 &#123;$$ = ($1) ? ($3) : 0;&#125; | NOT expr1 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; 优先级123456%token NUM LPAREN RPAREN ENTER PLUS MINUS TIMES DIVIDE AND OR NOT TRUE FALSE%left OR%left AND%right NOT%left PLUS MINUS%left TIMES DIVIDE cal.y123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657%&#123; #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int yylex(); int yyerror(char* s); #define YYSTYPE double /* 将Yacc栈定义为double类型 */ #define YYDEBUG 1 /* 允许debug模式 */%&#125;%token NUM LPAREN RPAREN ENTER PLUS MINUS TIMES DIVIDE AND OR NOT TRUE FALSE%left OR%left AND%right NOT%left PLUS MINUS%left TIMES DIVIDE%% /* 这样写prog可以让分析器每次读入一行进行分析，下一行重新分析expr */prog : prog expln | expln ;expln : expr ENTER &#123;if($$) printf("true\n");else printf("false\n");&#125; ; expr : expr PLUS term &#123;$$ = $1 + $3;&#125; | expr MINUS term &#123;$$ = $1 - $3;&#125; | term ; term : term TIMES factor &#123;$$ = $1 * $3;&#125; | term DIVIDE factor &#123;$$ = $1 / $3;&#125; | factor ; factor : LPAREN expr RPAREN &#123;$$ = $2;&#125; | MINUS factor &#123;$$ = - $2;&#125; | NUM &#123;$$ = $1;&#125; | expr1 ;expr1 : expr1 OR expr1 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr1 AND expr1 &#123;$$ = ($1) ? ($3) : 0;&#125; | NOT expr1 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; %%int main()&#123; // yydebug = 1; yyparse(); return 0;&#125; 非二义文法非二义文法12345678910111213141516E -&gt; E OR T | TT -&gt; T AND F | FF -&gt; NOT F | (F) | true | falseexpr1 : expr1 OR expr2 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr2 ;expr2 : expr2 AND expr3 &#123;$$ = ($1) ? ($3) : 0;&#125; | expr3 ;expr3 : NOT expr3 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; cal.y123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263%&#123; #include &lt;ctype.h&gt; #include &lt;stdio.h&gt; int yylex(); int yyerror(char* s); #define YYSTYPE double /* 将Yacc栈定义为double类型 */ #define YYDEBUG 1 /* 允许debug模式 */%&#125;%token NUM LPAREN RPAREN ENTER PLUS MINUS TIMES DIVIDE AND OR NOT TRUE FALSE%left OR%left AND%right NOT%left PLUS MINUS%left TIMES DIVIDE%% /* 这样写prog可以让分析器每次读入一行进行分析，下一行重新分析expr */prog : prog expln | expln ;expln : expr ENTER &#123;if($$) printf("true\n");else printf("false\n");&#125; ; expr : expr PLUS term &#123;$$ = $1 + $3;&#125; | expr MINUS term &#123;$$ = $1 - $3;&#125; | term ; term : term TIMES factor &#123;$$ = $1 * $3;&#125; | term DIVIDE factor &#123;$$ = $1 / $3;&#125; | factor ; factor : LPAREN expr RPAREN &#123;$$ = $2;&#125; | MINUS factor &#123;$$ = - $2;&#125; | NUM &#123;$$ = $1;&#125; | expr1 ;expr1 : expr1 OR expr2 &#123;$$ = ($1) ? 1 : ($3);&#125; | expr2 ;expr2 : expr2 AND expr3 &#123;$$ = ($1) ? ($3) : 0;&#125; | expr3 ;expr3 : NOT expr3 &#123;$$ = ($2) ? 0 : 1;&#125; | TRUE &#123;$$ = 1;&#125; | FALSE &#123;$$ = 0;&#125; ; %%int main()&#123; // yydebug = 1; yyparse(); return 0;&#125; makefile1234567891011121314151617181920cal3: cal.tab.o lex.yy.o gcc -o cal3 cal.tab.o lex.yy.o -lylex.yy.o: lex.yy.c cal.tab.h gcc -c lex.yy.ccal.tab.o: cal.tab.c gcc -c cal.tab.clex.yy.c: cal.l flex cal.lcal.tab.c: cal.y bison -dv cal.ycal.tab.h: cal.y echo "cal.tab.h was created at the same time as cal.tab.c."clean: rm -f cal3.exe lex.yy.o cal.tab.o lex.yy.c cal.tab.c cal.tab.h cal3.exe.stackdump cal.output 实验结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Lex设计词法分析器]]></title>
    <url>%2F2019%2F05%2F11%2F%E7%94%A8Lex%E8%AE%BE%E8%AE%A1%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实验内容Exp2使用lex为下述文法语言写一个词法分析器。 &lt;程序&gt; -&gt; PROGRAM &lt;标识符&gt; ; &lt;分程序&gt;&lt;分程序&gt; -&gt; &lt;变量说明&gt; BEGIN &lt;语句表&gt; END.&lt;变量说明&gt; -&gt; VAR &lt;变量说明表&gt;;&lt;变量说明表&gt; -&gt;&lt;变量表&gt;: &lt;类型&gt; | &lt;变量表&gt;: &lt;类型&gt;; &lt;变量说明表&gt;&lt;类型&gt;- &gt; INTEGER | REAL&lt;变量表&gt; -&gt; &lt;变量&gt; | &lt;变量&gt;, &lt;变量表&gt;&lt;语句表&gt; -&gt; &lt;语句&gt; | &lt;语句&gt;; &lt;语句表&gt;&lt;语句&gt; -&gt; &lt;赋值语句&gt; | &lt;条件语句&gt; | &lt;WHILE语句&gt; | &lt;复合语句&gt;&lt;赋值语句&gt; -&gt; &lt;变量&gt; := &lt;算术表达式&gt;&lt;条件语句&gt; -&gt; IF &lt;关系表达式&gt; THEN &lt;语句&gt; ELSE &lt;语句&gt; &lt;WHILE语句&gt; -&gt; WHILE &lt;关系表达式&gt; DO &lt;语句&gt;&lt;复合语句&gt; -&gt; BEGIN &lt;语句表&gt; END&lt;算术表达式&gt; -&gt; &lt;项&gt; | &lt;算术表达式&gt; + &lt;项&gt; | &lt;算术表达式&gt; - &lt;项&gt;&lt;项&gt; -&gt; &lt;因式&gt; | &lt;项&gt; * &lt;因式&gt; | &lt;项&gt; / &lt;因式&gt;&lt;因式&gt; -&gt; &lt;变量&gt; | &lt;常数&gt; | (&lt;算术表达式&gt;)&lt;关系表达式&gt; -&gt; &lt;算术表达式&gt; &lt;关系符&gt; &lt;算术表达式&gt;&lt;变量&gt; -&gt; &lt;标识符&gt;&lt;标识符&gt; -&gt; &lt;标识符&gt;&lt;字母&gt; | &lt;标识符&gt;&lt;数字&gt; | &lt;字母&gt;&lt;常数&gt; -&gt; &lt;整数&gt; | &lt;浮点数&gt;&lt;整数&gt; -&gt; &lt;数字&gt; | &lt;数字&gt; &lt;整数&gt;&lt;浮点数&gt; -&gt; .&lt;整数&gt; | &lt;整数&gt;.&lt;整数&gt;&lt;关系符&gt; -&gt; &lt; | &lt;= | = | &gt; | &gt;=| &lt;&gt;&lt;字母&gt; -&gt; A | B | …| X | Y | Z | a | b | …| x | y | z&lt;数字&gt; -&gt; 0|1|2|…|9 Exp3 要求每次调用词法分析函数yylex时，只返回一个记号(token)； 为记号选择适当的属性值，并且每次词法分析函数返回记号前，都将记号的属性值存入全局变量yylval中。（yylval可以自己定义为全局变量）； 记号属性值的选择：标识符的属性为标识符的名字字符串（例如，标识符name1的属性为字符串”name1”），整数的属性为整数值，浮点数的属性为浮点数值。其他记号属性值可自己选择。关键字可以省略属性。 注意：由于属性值需要存入yylval中，并且记号属性值的类型比较多（可能为字符串、整数、浮点数等），因此yylval必须能同时存放各种类型的值（提示：将yylval设置为union类型）。 在cygwin下用flex和gcc工具将实验调试通过，并能通过例子parser0中testcases目录下的test1.p测试例的测试。 实验过程添加记号名12345678910#define PROGRAM 36#define BEGIN1 37#define VAR 38#define THEN 39#define INT 40#define FLOAT 41#define END 42#define REAL 43#define COMMA 44#define COLON 45 正规定义12345int &#123;digit&#125;+(E[+-]?&#123;digit&#125;+)?float &#123;digit&#125;*(\.&#123;digit&#125;+)(E[+-]?&#123;digit&#125;+)? allow ((\\\\)|(\\\")|(\\\')|(\\&#123;letter&#125;)|(\\&#123;digit&#125;))*str (&#123;allow&#125;|[^\"\'\n\\])*\"end END|END. 定义yylval12345union data&#123; int inum; float fnum; char c[20];&#125;yylval; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/* 把讨厌的注释去掉 */%&#123;#include &lt;stdio.h&gt; #define LT 1#define LE 2#define GT 3#define GE 4#define EQ 5#define NE 6#define WHILE 18#define DO 19#define ID 20//#define NUMBER 21#define RELOP 22#define NEWLINE 23#define ERRORCHAR 24#define LEFTBRACKET 25#define RIGHTBRACKET 26#define SEMICOLON 27#define ASSIGN 28#define ARITHMETIC 29#define NOTE 30#define IF 31#define ELSE 32#define LEFTBRACES 33#define RIGHTBRACES 34#define STRING 35#define STRERROR 46#define PROGRAM 36#define BEGIN1 37#define VAR 38#define THEN 39#define INT 40#define FLOAT 41#define END 42#define REAL 43#define COMMA 44#define COLON 45union data&#123; int inum; float fnum; char c[20];&#125;yylval;%&#125;underline [_] delim [ \t \n]ws &#123;delim&#125;+letter [A-Za-z]digit [0-9]id &#123;underline&#125;*&#123;letter&#125;(&#123;letter&#125;|&#123;digit&#125;)*int &#123;digit&#125;+(E[+-]?&#123;digit&#125;+)?float &#123;digit&#125;*(\.&#123;digit&#125;+)(E[+-]?&#123;digit&#125;+)? allow ((\\\\)|(\\\")|(\\\')|(\\&#123;letter&#125;)|(\\&#123;digit&#125;))*str (&#123;allow&#125;|[^\"\'\n\\])*\"end END|END./* 状态（或条件）定义可以定义在这里 * INITIAL是一个默认的状态，不需要定义 */%s COMMENT%s NOTE1%s QUOTE%%&lt;INITIAL&gt;"/*" &#123;BEGIN COMMENT;&#125;&lt;COMMENT&gt;"*/" &#123;BEGIN INITIAL;&#125;&lt;COMMENT&gt;.|\n &#123;;&#125;&lt;INITIAL&gt;"//" &#123;BEGIN NOTE1;&#125;&lt;NOTE1&gt;\n &#123;BEGIN INITIAL;&#125;&lt;NOTE1&gt;. &#123;;&#125;&lt;INITIAL&gt;"\"" &#123;BEGIN QUOTE;&#125;&lt;QUOTE&gt;"\"" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;"\n" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;&#123;str&#125; &#123;BEGIN INITIAL; return (STRING);&#125;&lt;QUOTE&gt;[^\"\n] &#123;;&#125;&lt;INITIAL&gt;&#123;ws&#125; &#123;;&#125;&lt;INITIAL&gt;PROGRAM &#123;return (PROGRAM);&#125;&lt;INITIAL&gt;BEGIN &#123;return (BEGIN1);&#125;&lt;INITIAL&gt;&#123;end&#125; &#123;return (END);&#125;&lt;INITIAL&gt;WHILE &#123;return (WHILE);&#125;&lt;INITIAL&gt;DO &#123;return (DO);&#125;&lt;INITIAL&gt;IF &#123;return (IF);&#125;&lt;INITIAL&gt;THEN &#123;return (THEN);&#125;&lt;INITIAL&gt;ELSE &#123;return (ELSE);&#125;&lt;INITIAL&gt;while &#123;return (WHILE);&#125;&lt;INITIAL&gt;do &#123;return (DO);&#125;&lt;INITIAL&gt;if &#123;return (IF);&#125;&lt;INITIAL&gt;else &#123;return (ELSE);&#125;&lt;INITIAL&gt;then &#123;return (THEN);&#125;&lt;INITIAL&gt;VAR &#123;return (VAR);&#125;&lt;INITIAL&gt;&#123;int&#125; &#123;sscanf(yytext,"%d",&amp;yylval.inum); return (INT);&#125;&lt;INITIAL&gt;&#123;float&#125; &#123;sscanf(yytext,"%f",&amp;yylval.fnum); return (FLOAT);&#125;&lt;INITIAL&gt;REAL &#123;return (REAL);&#125;&lt;INITIAL&gt;&#123;id&#125; &#123;sscanf(yytext,"%s",&amp;yylval.c); return (ID);&#125;&lt;INITIAL&gt;"&lt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&lt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"==" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"!=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"(" &#123;return (LEFTBRACKET);&#125;&lt;INITIAL&gt;")" &#123;return (RIGHTBRACKET);&#125;&lt;INITIAL&gt;"&#123;" &#123;return (LEFTBRACES);&#125;&lt;INITIAL&gt;"&#125;" &#123;return (RIGHTBRACES);&#125;&lt;INITIAL&gt;";" &#123;return (SEMICOLON);&#125;&lt;INITIAL&gt;"=" &#123;return (ASSIGN);&#125;&lt;INITIAL&gt;":=" &#123;return (ASSIGN);&#125;&lt;INITIAL&gt;":" &#123;return (COLON);&#125;&lt;INITIAL&gt;"+" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"-" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"*" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"/" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"," &#123;return (COMMA);&#125;&lt;INITIAL&gt;. &#123;return ERRORCHAR;&#125;%%int yywrap ()&#123; return 1;&#125;void writeout(int c)&#123; switch(c)&#123; case ERRORCHAR: fprintf(yyout, "(ERRORCHAR, \"%s\") ", yytext);break; case PROGRAM: fprintf(yyout, "(PROGRAM, \"%s\") ", yytext);break; case BEGIN1: fprintf(yyout, "(BEGIN, \"%s\") ", yytext);break; case END: fprintf(yyout, "(END, \"%s\") ", yytext);break; case IF: fprintf(yyout, "(IF, \"%s\") ", yytext);break; case THEN: fprintf(yyout, "(THEN, \"%s\") ", yytext);break; case ELSE: fprintf(yyout, "(ELSE, \"%s\") ", yytext);break; case VAR: fprintf(yyout, "(VAR, \"%s\") ", yytext);break; case INT: fprintf(yyout, "(INT, \"%s\") ", yytext);break; case FLOAT: fprintf(yyout, "(FLOAT, \"%s\") ", yytext);break; case REAL: fprintf(yyout, "(REAL, \"%s\") ", yytext);break; case COMMA: fprintf(yyout, "(COMMA, \"%s\") ", yytext);break; case COLON: fprintf(yyout, "(COLON, \"%s\") ", yytext);break; case RELOP: fprintf(yyout, "(RELOP, \"%s\") ", yytext);break; case WHILE: fprintf(yyout, "(WHILE, \"%s\") ", yytext);break; case DO: fprintf(yyout, "(DO, \"%s\") ", yytext);break; case ID: fprintf(yyout, "(ID, \"%s\") ", yytext);break; case LEFTBRACKET: fprintf(yyout, "(LEFTBRACKET, \"%s\") ", yytext);break; case RIGHTBRACKET: fprintf(yyout, "(RIGHTBRACKET, \"%s\") ", yytext);break; case LEFTBRACES: fprintf(yyout, "(LEFTBRACES, \"%s\") ", yytext);break; case RIGHTBRACES: fprintf(yyout, "(RIGHTBRACES, \"%s\") ", yytext);break; case SEMICOLON: fprintf(yyout, "(SEMICOLON, \"%s\") ", yytext);break; case ASSIGN: fprintf(yyout, "(ASSIGN, \"%s\") ", yytext);break; case ARITHMETIC: fprintf(yyout, "(ARITHMETIC, \"%s\") ", yytext);break; case NOTE: fprintf(yyout, "(NOTE, \"%s\") ", yytext);break; case NEWLINE: fprintf(yyout, "\n");break; case STRING: fprintf(yyout, "(STRING, \"%s\") ", yytext);break; default:break; &#125; return;&#125;int main (int argc, char ** argv)&#123; int c,j=0; if (argc&gt;=2)&#123; if ((yyin = fopen(argv[1], "r")) == NULL)&#123; printf("Can't open file %s\n", argv[1]); return 1; &#125; if (argc&gt;=3)&#123; yyout=fopen(argv[2], "w"); &#125; &#125; while (c = yylex())&#123; writeout(c); j++; if (j%5 == 0) writeout(NEWLINE); &#125; if(argc&gt;=2)&#123; fclose(yyin); if (argc&gt;=3) fclose(yyout); &#125; return 0;&#125; 实验结果测试样例 运行结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cygwin环境的熟悉和lex的使用1]]></title>
    <url>%2F2019%2F05%2F11%2FCygwin%E7%8E%AF%E5%A2%83%E7%9A%84%E7%86%9F%E6%82%89%E5%92%8Clex%E7%9A%84%E4%BD%BF%E7%94%A81%2F</url>
    <content type="text"><![CDATA[实验内容Exp1读懂exam1.l和exam2.l两个例子，使用cygwin下的flex工具将exam1.l和exam2.l编译并调试通过。并且修改exam2.l，在其基础上增加如下记号： 左右大小括号：{ } ( ) 将关系算符改写成C中的形式 分号、赋值号：; = 关键字：if else 双斜线表示的注释：// 算术运算符号：+ - * / 将标识符改为可含有下划线，并且可以以下划线开头 将注释内容忽略 Exp e1在实验1所改写的程序的基础上增加识别string记号。string是字符串，如果”出现在字符串中，则必须转义，写成\”形式；如果\出现在字符串中，也必须转义，写成\形式。 在cygwin下用flex和gcc工具将实验调试通过，并写出测试例测试正确性。同时该实验必须满足如下要求： string是字符串，它是以双引号括起的一串字符。 双引号内的字符有如下要求： 不能包含单独的”或者\，除非用\进行转义。例如字符串内的”写成\”，而\写成\。 字符串内可以出现转义字符。转义字符可简化表示为\c，其中c为任意字母或(反斜杠),”（双引号）,’（单引号）三个符号中的一个。 字符串内不可包含实体的换行。（可以包含\n，但是如果两个“”中的字符串出现在两行中，即包含了实体换行，则不应识别为字符串） 实验过程Exp1添加记号名12345678910111213#define NEWLINE 23#define ERRORCHAR 24#define LEFTBRACKET 25 //bracket 为小括号 ： （）#define RIGHTBRACKET 26#define SEMICOLON 27 //分号#define ASSIGN 28 //赋值#define ARITHMETIC 29 //算术#define NOTE 30 注释#define IF 31#define ELSE 32#define LEFTBRACES 33 //braces 为大括号 ： &#123; &#125;#define RIGHTBRACES 34 定义动作123456789101112131415161718&lt;INITIAL&gt;"&lt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&lt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"==" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"!=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"&gt;=" &#123;return (RELOP);&#125;&lt;INITIAL&gt;"(" &#123;return (LEFTBRACKET);&#125;&lt;INITIAL&gt;")" &#123;return (RIGHTBRACKET);&#125;&lt;INITIAL&gt;"&#123;" &#123;return (LEFTBRACES);&#125;&lt;INITIAL&gt;"&#125;" &#123;return (RIGHTBRACES);&#125;&lt;INITIAL&gt;";" &#123;return (SEMICOLON);&#125;&lt;INITIAL&gt;"=" &#123;return (ASSIGN);&#125;&lt;INITIAL&gt;"+" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"-" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"*" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;"/" &#123;return (ARITHMETIC);&#125;&lt;INITIAL&gt;. &#123;return ERRORCHAR;&#125; 更改writeout函数1234567891011121314151617181920212223void writeout(int c)&#123; switch(c)&#123; case ERRORCHAR: fprintf(yyout, "(ERRORCHAR, \"%s\") ", yytext);break; case RELOP: fprintf(yyout, "(RELOP, \"%s\") ", yytext);break; case WHILE: fprintf(yyout, "(WHILE, \"%s\") ", yytext);break; case DO: fprintf(yyout, "(DO, \"%s\") ", yytext);break; case NUMBER: fprintf(yyout, "(NUM, \"%s\") ", yytext);break; case ID: fprintf(yyout, "(ID, \"%s\") ", yytext);break; case LEFTBRACKET: fprintf(yyout, "(LEFTBRACKET, \"%s\") ", yytext);break; case RIGHTBRACKET: fprintf(yyout, "(RIGHTBRACKET, \"%s\") ", yytext);break; case LEFTBRACES: fprintf(yyout, "(LEFTBRACES, \"%s\") ", yytext);break; case RIGHTBRACES: fprintf(yyout, "(RIGHTBRACES, \"%s\") ", yytext);break; case SEMICOLON: fprintf(yyout, "(SEMICOLON, \"%s\") ", yytext);break; case ASSIGN: fprintf(yyout, "(ASSIGN, \"%s\") ", yytext);break; case ARITHMETIC: fprintf(yyout, "(ARITHMETIC, \"%s\") ", yytext);break; case NOTE: fprintf(yyout, "(NOTE, \"%s\") ", yytext);break; case IF: fprintf(yyout, "(IF, \"%s\") ", yytext);break; case ELSE: fprintf(yyout, "(ELSE, \"%s\") ", yytext);break; case NEWLINE: fprintf(yyout, "\n");break; default:break; &#125; return;&#125; Exp e1增加String记号12#define STRING 35#define STRERROR 36 进行正规定义12allow ((\\\\)|(\\\")|(\\\')|(\\&#123;letter&#125;)|(\\&#123;digit&#125;))*str (&#123;allow&#125;|[^\"\'\n\\])*\" 增加引用状态12345&lt;INITIAL&gt;"\"" &#123;BEGIN QUOTE;&#125;&lt;QUOTE&gt;"\"" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;"\n" &#123;BEGIN INITIAL;&#125;&lt;QUOTE&gt;&#123;str&#125; &#123;BEGIN INITIAL; return (STRING);&#125;&lt;QUOTE&gt;[^\"\n] &#123;;&#125; QUOTE状态以双引号开始，双引号结束，当匹配到除字符串str和单引号、回车之外的任意字符，返回ERRORCHAR 当QUOTE状态下，遇到回车则进入INITIAL状态 实验结果编译运行123flex exam2.lettergcc lex.yy.c -lfl./a.out test2.p 对于不满足string条件的STRERROR直接不输出 对于string6 , 在本分析器中当遇到第一个双引号时，进入QUOTE状态，之后string6”被识别为str类型，但虽然str以双引号结尾，但不将双引号作为字符串的一部分，（如果string6”被作为字符串的话，string6””应该被识别为str类型） 之后，QUOTE状态结束，遇到双引号又进入QUOTE状态，遇到回车，结束QUOTE状态 对于string2 ， string3: ​ allow ((\\\\)|(\\\&quot;)|(\\\&#39;)|(\\{letter})|(\\{digit}))* ​ “ \ ”、“ \” ”属于allow范围，因此包含在字符串内 对于string4: “\n \’ \0 \a”均属于allow范围，包含在字符串内 对于string5，string7，string，8，没有匹配到合适的str类型，因此匹配到的STRERROR类型不输出，最后不会有输出结果]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>Exp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[新建仓库新建名为 yourgithubname.github.io 的仓库 Git Nodejs直接官网安装 Git 、Nodejs 配置SSH-KEYssh-keygen -t rsa -C &quot;邮件地址&quot; 连续三次回车，会生成key在用户文件目录下，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的 github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： $ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 测试KEY$ ssh -T git@github.com 邮箱地址不用换 如果看到 Hi XX! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 证明已经成功 Host key verification failed如果提示 Host key verification failed ， 输入 ssh-keyscan -H github.com &gt;&gt; ~/.ssh/known_hosts 之后重新测试 npm install hexo安装hexo]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字图像处理-图像合成]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%2F</url>
    <content type="text"><![CDATA[图像分割选择特定拓展名12345678img_path = &apos;pics/&apos;;ext = &#123;&apos;*.jpeg&apos;,&apos;*.jpg&apos;,&apos;*.png&apos;&#125;;img_list = [];for i = 1:numel(ext) img_list = [img_list ; dir(fullfile(img_path,ext&#123;i&#125;))];endimg_num = length(img_list); 转换为特定尺寸的灰度图像1234567891011if img_num &gt; 0 for j = 1 : img_num img_name = img_list(j).name; img = imread(strcat(img_path,img_name)); img = imresize(img,[640 480]); G = rgb2gray(img); strname = strsplit(img_name,&apos;.&apos;); name = strname&#123;1,1&#125;; imwrite(G , strcat(img_path, name , &apos;.gif&apos;)); endend 求素材图片的RGB平均值123456789101112131415161718192021SIZE = 5;img_RGB = zeros(img_num,SIZE,SIZE,3);average_rgb = zeros(img_num,3);if img_num &gt; 0 for j = 1:img_num img_name = img_list(j).name; img = imread(strcat(img_path,img_name)); img = imresize(img,[SIZE SIZE]); img_RGB(j,:,:,:) = img; R = img(:,:,1); G = img(:,:,2); B = img(:,:,3); average_rgb(j,1)=mean(mean(R)); average_rgb(j,2)=mean(mean(G)); average_rgb(j,3)=mean(mean(B)); endend 替换为素材图片123456789101112131415161718192021222324252627original_Img = (&apos;original.png&apos;);Image_size = size(original_Img);Image_RGB = zeros(Image_size(1),Image_size(2),3);Image_RGB = original_Img(:,:,:);for row = 1 : SIZE :Image_size(1)-SIZE for col = 1 : SIZE :Image_size(2)-SIZE rgb_mean = zeros(3); for k = 1:3 temp = original_Img(row:row+SIZE-1 ,col:col+SIZE-1,k); rgb_mean(k) = mean(mean(temp)); end deviation = zeros(1,img_num); for k = 1:img_num deviation(k) = abs(average_rgb(k,1) - rgb_mean(1)) + abs(average_rgb(k,2) - rgb_mean(2)) + abs(average_rgb(k,3) - rgb_mean(3)); 求目标区域与每一个素材图片的RGB误差 end [min_value,min_position] = min(deviation); %得到最小值下标 Image_RGB(row:row+SIZE-1 ,col:col+SIZE-1,:) = img_RGB(min_position,:,:,:); endendImage_RGB = uint8(Image_RGB);imwrite(Image_RGB,&apos;0.jpg&apos;); 实验结果素材图片 original pic After]]></content>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI-02深度学习概述]]></title>
    <url>%2F2019%2F03%2F04%2FAI-02%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[M-P神经元 为什么需要激活函数 激活函数举例 权重人工设置m-p神经元的权重由人工设置，无法学习 单层感知器首个可以学习的神经网络 逻辑实现 多层感知器异或 单层感知器，无法实现异或关系，无法找到一条线完美分开数据（0、1） 同或 单隐层神经网络可视化urlhttp://playground.tensorflow.org/ 万有逼近定理 双隐层感知器 神经网络每一层作用 更深 or 更宽]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI_01人工智能概述]]></title>
    <url>%2F2019%2F03%2F04%2FAI-01%2F</url>
    <content type="text"><![CDATA[人工智能&amp;机器学习什么是人工智能人工智能(Artificial Intelligence)使一部机器像人一样进行感知、认知、决策、执行的人工程序或系统 标志性事件 人工智能发展阶段 人工智能三个层面计算智能能存能算 感知智能能听会说、能看会认 认知智能能理解、会思考 人工智能 &gt; 机器学习 &gt; 深度学习 逻辑演绎 vs 归纳总结 专家系统根据专家定义的知识和经验，进行推理和判断，从而模拟人类专家的决策过程来解决问题。 知识工程 vs 机器学习 计算机视觉人脸识别图像分类目标检测图像搜索图像分割视频监控语音技术语音识别语音合成声纹识别自然语言处理文本分类机器翻译知识图谱自动问答信息检索文本生成机器学习的定义最常用定义计算机系统能够利用经验提高自身的性能 可操作定义机器学习本质是一个基于经验数据的函数估计问题 统计学定义提取重要模式、趋势，并理解数据，即从数据中学习 机器学习-怎么学模型对要学习问题映射的假设（问题建模，确定假设空间） 模型分类数据标记 监督学习模型 无监督学习模型 数据分布参数模型 、 无参数模型 建模对象 判别模型 生成模型 策略从假设空间中学习/选择最优模型的准则（确定目标函数） 算法根据目标函数求解最优模型的具体计算方法（求解模型参数） 深度学习传统机器学习：人工设计特征 传统机器学习VS 深度学习 手动设计程序 手动设计特征 神经网络结构发展 深度学习的不能 连接主义 vs 符号主义 从对立到合作 连接主义+ 符号主义]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题Google验证]]></title>
    <url>%2F2019%2F02%2F23%2Fhexo-google-verify%2F</url>
    <content type="text"><![CDATA[Google验证urlhttps://www.google.com/webmasters 修改配置文件使用html标签验证，方法同baidu验证 在站点配置文件中添加 google_site_verification: 123xxxxxx321 使用hexo d提交，刷新页面，查看源代码，如果能看到一下内容，证明标签已经成功添加： 进行验证 添加sitemap添加sitemap]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo_image]]></title>
    <url>%2F2019%2F02%2F19%2Fhexo-image%2F</url>
    <content type="text"><![CDATA[hexo md文档添加图片修改站点配置文件post_asset_folder 字段置为true 修改后，当进入到/source/_posts 下使用 hexo n xxx 建立新的文章时，会自动生成一个相同命名的文件夹，用于存放文章中引用的图片等资源， 在md文档中引用时，使用相对路径 插件安装安装插件 使用命令 npm install https://github.com/CodeFalling/hexo-asset-image --save 保存预览hexo g hexo s]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Next主题baidu验证]]></title>
    <url>%2F2019%2F02%2F17%2Fhexo_baidu_verify%2F</url>
    <content type="text"><![CDATA[baidu验证验证未收录百度搜索 site:yourgithub.github.io , 验证未收录 百度搜索平台进入百度搜索平台，点击链接提交，填写github地址 记录content值验证站点，选择html标签验证，记录content值 添加代码在themes/next下的配置文件最后添加代码 baidu_site_verification: 5xxxxxxQ 重新生成提交，无需修改head文件 刷新github页面，查看网站源代码，当可以找到正确的验证标签时，进行验证。 验证通过 等待通过，通过后进行推送 推送主动推送最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。 自动推送最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。 sitemap您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。 手动提交一次性提交链接给百度，可以使用此种方式。 主动推送&gt;自动推送&gt;sitemap主动推送安装hexo-baidu-url-submit插件git bash 命令 npm install hexo-baidu-url-submit --save 添加baidu-url-submit的配置项站点配置文件中添加： #设置百度主动推送baidu_url_submit: count: 200 #比如200，代表提交最新的200个链接 host: www.lansheng.net.cn # 在百度站长平台中注册的域名，这个改为你自己的域名 token: your_token # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，这个默认 同时注意修改站点配置文件中的url值 加入新的deploy配置项两个type前都要加‘ - ’，表明层次 deploy: - type: gitrepo: coding: git@git.coding.net:你的coding用户名/你的coding用户名.coding.me.git #coding地址 github: git@github.com:你的github用户名/你的github用户名.github.io.git # Github地址branch: master - type: baidu_url_submitter 验证配置是否成功hexo d部署后查看反馈： 自动推送设置baidu_push将主题配置文件中的baidu_push置为 true 自动推送代码位于 themes\next\layout\_third-party\baidu-push.swig Sitemap安装baidu 、Google插件git bash命令 npm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 修改配置文件修改站点配置文件，添加 # 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 编译hexo clean &amp;&amp; hexo g 更换站点地图文件url将地图文件中的yoursite.com更换成自己的url 在站长管理中提交地图]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>baidu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
